{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/blog_img/golang-1200x675.png","path":"img/blog_img/golang-1200x675.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/top_img/602933.jpg","path":"img/top_img/602933.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/top_img/mz_night.jpg","path":"img/top_img/mz_night.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/blog_img/hexo.png","path":"img/blog_img/hexo.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/blog_img/hexo_blog_01.png","path":"img/blog_img/hexo_blog_01.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/blog_img/hexo_blog_02.png","path":"img/blog_img/hexo_blog_02.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/blog_img/hexo_blog_04.png","path":"img/blog_img/hexo_blog_04.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/blog_img/hexo_blog_05.png","path":"img/blog_img/hexo_blog_05.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/blog_img/hexo_blog_03.png","path":"img/blog_img/hexo_blog_03.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/blog_img/hexo_blog_06.png","path":"img/blog_img/hexo_blog_06.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/blog_img/hexo_blog_07.png","path":"img/blog_img/hexo_blog_07.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/blog_img/hexo_blog_08.png","path":"img/blog_img/hexo_blog_08.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/blog_img/hexo_blog_09.png","path":"img/blog_img/hexo_blog_09.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/blog_img/hexo_blog_10.png","path":"img/blog_img/hexo_blog_10.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/blog_img/hexo_blog_11.png","path":"img/blog_img/hexo_blog_11.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/golang-mistakes.md","hash":"f06dcac23f0053fe17de2ff727f3d94d8b809c64","modified":1628668322001},{"_id":"source/categories/index.md","hash":"7efcc5b670a80f5586983408f04da43ecc04a5ca","modified":1628668322001},{"_id":"source/golang-learning/index.md","hash":"3b15d2b7e4a5267ecff5ad5a1742e4a7a4873e2b","modified":1628668322001},{"_id":"source/tags/index.md","hash":"d9c2ea4d836d3de98f5fbdae0c7ebc6d71bc5311","modified":1628668322001},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1628668510641},{"_id":"themes/butterfly/README.md","hash":"cedd13fcd8c75a68742265dd8eced4087e940ffd","modified":1628668510641},{"_id":"themes/butterfly/README_CN.md","hash":"459d6f3200863021bee1fe72a719aef236fb4090","modified":1628668510641},{"_id":"themes/butterfly/_config.yml","hash":"240662a3997d00b0e3ea54f8f47fb0b34a31b164","modified":1628668510641},{"_id":"themes/butterfly/package.json","hash":"0ea30490a4a31cea88f228e4db5d7c021ef23117","modified":1628668510661},{"_id":"themes/butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1628668510641},{"_id":"themes/butterfly/languages/default.yml","hash":"7ca673fb629ea74f5ba5e75b4f0f95248cfb5090","modified":1628668510641},{"_id":"themes/butterfly/languages/en.yml","hash":"cd333235ff1648a6bf58dfafc81f2c57672a15a5","modified":1628668510641},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"741e522b2387f94764a73844e7b084cc7e927c54","modified":1628668510641},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"79a50c40d9f5463f1fa42aa870ac6b8b84540412","modified":1628668510641},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1628668510641},{"_id":"themes/butterfly/layout/category.pug","hash":"60c1b795b6e227b5dd81963b51d29d1b81d0bf49","modified":1628668510641},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1628668510661},{"_id":"themes/butterfly/layout/page.pug","hash":"82aa988527a11835e7ac86ce4f23b8cd20014dfa","modified":1628668510661},{"_id":"themes/butterfly/layout/post.pug","hash":"8d398c8925182699d9f2b9f1b727f06228488312","modified":1628668510661},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1628668510661},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":1628668510641},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1628668510641},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1628668510641},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"7d378e328a53cc99d5acc9682dce53f5eb61537d","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"4156224c47bfc2482281ac4e4df701c30476ff00","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"1377952022ee0a9eaa7a2fd1098f1571efc468d9","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"6f2608c4d93d3d10ae6b2cd7f8918f303f024321","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"2d0453adf92a3fd3466cf0793f14685d17b8b51d","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"8dafc2dcd8c33f70a546fee443f0b6d80b3cd243","modified":1628668510651},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1628668510661},{"_id":"themes/butterfly/scripts/events/init.js","hash":"018aa446265fe627301b1d53d7cba4f4ff1960ac","modified":1628668510661},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":1628668510661},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"4cc2d517195c8779471d326ada09f9371cbad4dd","modified":1628668510661},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"9821872007cf57efae4b728dc575ef9d004547bb","modified":1628668510661},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1628668510661},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1628668510661},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"65f2442e04c4defd16e7c1e67701d3bb41d9577a","modified":1628668510661},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":1628668510661},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"54b9324e3506dcc9c9991ef5e11e37e66e21594f","modified":1628668510661},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"b816ded1451f28c7c54151ffe6c259b110253ae3","modified":1628668510671},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"94826ea6bcc4d2304199adae12c4e2b272caf529","modified":1628668510671},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"f33858ffb9e88191e644796e11d2f901eb332308","modified":1628668510671},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1628668510671},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1628668510671},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"35f073021db93699fcac9ef351e26c59c31aadf7","modified":1628668510671},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1628668510671},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1628668510671},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1628668510671},{"_id":"themes/butterfly/source/css/var.styl","hash":"40c3f64422205a24e68ce1ad8fe8163f24fdd525","modified":1628668510671},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1628668510671},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1628668510671},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1628668510671},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1628668510681},{"_id":"themes/butterfly/source/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1628668510691},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1628668510701},{"_id":"themes/butterfly/source/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1628668510701},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"90d01b88d0f406d00184960b1afe9230aec2ebe6","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"4def0aab9e2172ad1f29abd1535d8e08ff23aa0b","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"889ef16fa34a39e5533bc170e62f20f3450cc522","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"e55f8bdb876d5429a908498db1307b94094c0d06","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"24370508ee87f14418e8f06e9d79ad8c52a342c4","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"c205b9fd72b2fe19e6d15c5b5ab0fb38c653032e","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"92f81a437c9db49f7ebcf608bc09488ecdb55a21","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"4c3c5cb69b3aead8c232cb0fbc251929f28aad75","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"1f30952fed73dec21b42e2e30b7fe2e84618d2e4","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"dbec869c62135695495703a29ad7655e9965d461","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"b53a2d4f9c37b375a4446d2273dcfb7712d91b3e","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"93d4ebc7dc8228c7a10ddeb5a553d0dcdabbe145","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1628668510641},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"5b404356f311d2ee36478291ca3553210867b738","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"933cb710d2dbcea25c6426a57c6f49d2f48b792c","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"d50e5c22cd6bc3c378bc581918136746cfa3447f","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"3d8e3706a056389176f55dd21956aabc78046761","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"0366c658cdcff839aa1df2e2d252a03a53fd427e","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"27afd2274bd5f2cbbf1bad9f0afe2b2b72c213ca","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"ae9336bf31cdad08ff586ead4295912a96563c76","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"b5525891f6affd02c1ea3b2327c026882efe428b","modified":1628668510661},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"eda47f3e807a466ba8275627ea936c5100c43818","modified":1628668510671},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"316246208726518418bb16a17d15ca6c0bcdeafc","modified":1628668510671},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"85e72c70a0cef29e40be1968f5d23b06c6f8e3aa","modified":1628668510671},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"fa7a4c1685f391d60ed863e869b9604b59746c27","modified":1628668510671},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"7feb755ca7c22da36bbad11e74ecd95fdcf3b879","modified":1628668510671},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1628668510671},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"f1b63892baafa48ab872bc79671d57aafd511f6c","modified":1628668510671},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"dd8cdf639ba2b726437c77fa7aa8d5edbabe8f9b","modified":1628668510671},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"98235fcda3b87ad6f7e91eafbed94d0d6ae847ca","modified":1628668510671},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":1628668510671},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"90fe01c968696a9f791cb2b84fca621cbbb56f47","modified":1628668510671},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"d748951d9fbcd04dda839085af78b01b8fa04cba","modified":1628668510671},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"0551c5893d1589a3d17ce161e50ecb1d724cc6e8","modified":1628668510671},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"ea1ba40dd5954c2ed718a126336fb7f94da4e66f","modified":1628668510671},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"7a072589e6097dbe942783131964f2372fdf1eb6","modified":1628668510671},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"2c5fb77c448ce0a734040c8ce532b28fed688899","modified":1628668510671},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"978c397d0966eaf9e6e2afd13866f8f4900b509f","modified":1628668510671},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"f59a9a0059d5261251bdd6de45aa97dd2d11e633","modified":1628668510671},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"b0488ceacde74af139d66c8db5cb36cc21737b9b","modified":1628668510671},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":1628668510671},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"4e629f510b73f998ab208b739c5bd7dcd168d1a7","modified":1628668510671},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"e554549f0a0ae85362f0b0e8687981741f486f6b","modified":1628668510671},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"97fec1e814f88237862f4d800a35362b802f6625","modified":1628668510671},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"2cc49d3f6a6beb9f7bff93e292f88aa5681da1d0","modified":1628668510671},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"7c4152162a03aa8331a783df5695e4ebbb816a8c","modified":1628668510671},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9a881c031f463c486bd25248c2814fd09f97892b","modified":1628668510671},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"917e0e399e117217184ca63d3eb5c4843bcccf7b","modified":1628668510671},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"f168f5c669978f633abe118cdcc4a12cfc883c01","modified":1628668510671},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"6befe4c51b86d0c1de130beeecad9e28d6442713","modified":1628668510671},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"1c3f9d7efc3b9dfcfa8926a1132d0c44ffc7d4b2","modified":1628668510671},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"53ecae272e16223a436c497abbf25dd5f0fc4aaa","modified":1628668510671},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":1628668510671},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"21964fdd6d74ffbea519418bab65024aee5f3736","modified":1628668510671},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1628668510671},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"f741e85295ce15c70a6027ec15a542636dd5dcca","modified":1628668510671},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"86fee274a62f7f034547342930f445c47378eb55","modified":1628668510671},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":1628668510671},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1628668510671},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1628668510691},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1628668510701},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"400ce038548d6f9ddb486150c724c87b6923a88b","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"143236e395c18d80ab8dc794821eb337c85f6b32","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"c46a932257212f82e4a9974fbbc5de8878c8b383","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"9c96e6e67931977268b218b99084b98597c2e42b","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"da9813f8dc0d388869c15413cf056012cfb69e1a","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"bafb3d5710824caa59a56017afb058fd2b4eac65","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"16378d8646ea3f4ac99c18f0296dd85b13f9d775","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"59c22ebf3aaee90152e7cdb17ff5841c888fcd82","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"360845d02c3864975349ae60b3d0c68253ca001c","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f9b00ead54573ba6e6eb33481588af144aab648d","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"a47d8f9f593091cc91192c0c49deaa2c0d2317fd","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"3f3a3cd8bea2103dedd754f767aca5cb84d5f586","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"b443d6b16baf3ea250041342cc0361a42a412b7f","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"34088a15655704d12e9b1807b47b3f6a860c9eec","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":1628668510651},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"cb38ffe911023092a90a28f2ba8317a92b22cd0c","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"59b4c26a827ace5a54855881d199977103ff6f50","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"a2bc2601b7e0ae5caf1fc51a07390562d928620a","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"d8f59e94eafc669c49349561dc5bbea3915aecb7","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"613280d61b8ab9612014ec016ae3d3698d36fd1a","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1628668510661},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":1628668510661},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"8c0726fb8d9a497d2f900b0be2845efaa68e3d87","modified":1628668510671},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"89cbcc8e087788ecec18b5fa58710afacdb7d080","modified":1628668510671},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1628668510671},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"e0e7065124ef0d99f8322a47bc47838982e04ad0","modified":1628668510671},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1628668510671},{"_id":"themes/butterfly/source/img/blog_img/golang-1200x675.png","hash":"cc68870ef558d003e73520cbe592e51e37a98220","modified":1628668510671},{"_id":"themes/butterfly/source/img/top_img/mz_night.jpg","hash":"506c5f27ef20479a0c4efbf6464816596b34b18a","modified":1628668510691},{"_id":"themes/butterfly/source/img/top_img/602933.jpg","hash":"296ed6b4bcce5ec65ca6673f29a6486e7745e700","modified":1628668510691},{"_id":"public/atom.xml","hash":"8a5beb32878ed599a2b404fd4ceb7e6b02b34fcf","modified":1628784046356},{"_id":"public/sitemap.xml","hash":"efe7dcbbf4e3c7e01872225d31d77c28a946f935","modified":1628782351175},{"_id":"public/golang-learning/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1628668726610},{"_id":"public/categories/index.html","hash":"90ba35cd9a5d461a0b9965466d9c07d49d2bcd3b","modified":1628784046356},{"_id":"public/tags/index.html","hash":"579420beb44c465659255976207bb6264f3259c6","modified":1628784046356},{"_id":"public/archives/index.html","hash":"5c0b46f8140021f13f26226d621b6bb189d823dc","modified":1628784046356},{"_id":"public/archives/2021/index.html","hash":"404a76a59b233dcd61c76f99dc2b9a35e2d0a7ce","modified":1628784046356},{"_id":"public/archives/2021/08/index.html","hash":"c604a93a89011830b027b82517c35857ddaec177","modified":1628784046356},{"_id":"public/categories/golang/index.html","hash":"a8e92c443237833b9bc4a8821efc79ebe4232f53","modified":1628784046356},{"_id":"public/index.html","hash":"225251eee96544e03a18540b624c3f42a4e73605","modified":1628784046356},{"_id":"public/tags/golang/index.html","hash":"dfaf84d85e3ac442da6e2df4eef6ebdb6d76f48f","modified":1628784046356},{"_id":"public/2021/08/11/golang-mistakes/index.html","hash":"8330ad54556b180acc7fcd16daf2450d990044df","modified":1628668726610},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1628668726610},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1628668726610},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1628668726610},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1628668726610},{"_id":"public/img/blog_img/golang-1200x675.png","hash":"cc68870ef558d003e73520cbe592e51e37a98220","modified":1628668726610},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1628668726610},{"_id":"public/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1628668726610},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1628668726610},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1628668726610},{"_id":"public/css/index.css","hash":"ba7121426d854ff25b335fb6dd9af4894531e81d","modified":1628668726610},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1628668726610},{"_id":"public/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1628668726610},{"_id":"public/img/top_img/mz_night.jpg","hash":"506c5f27ef20479a0c4efbf6464816596b34b18a","modified":1628668726610},{"_id":"public/img/top_img/602933.jpg","hash":"296ed6b4bcce5ec65ca6673f29a6486e7745e700","modified":1628668726610},{"_id":"source/_posts/hexo/hexo-deploy.md","hash":"d295ed7c7bb6651b1bcc808551f75e3749597e33","modified":1628784031210},{"_id":"source/_posts/golang/golang-mistakes.md","hash":"f06dcac23f0053fe17de2ff727f3d94d8b809c64","modified":1628668322000},{"_id":"themes/butterfly/source/img/blog_img/hexo.png","hash":"489eae5c8763d484d61944ab769b4e16882adadf","modified":1628694902000},{"_id":"public/categories/博客搭建/index.html","hash":"1cc0c5dbcff68565eab2e86ac783e9b9f2af4bdc","modified":1628784046356},{"_id":"public/tags/博客搭建/index.html","hash":"967466e0b19f68e299564a2d2615a20af6fbdce5","modified":1628784046356},{"_id":"public/tags/hexo/index.html","hash":"48858cf8b53e13933a59d8620b0422329be5b0bd","modified":1628784046356},{"_id":"public/2021/08/12/golang/golang-mistakes/index.html","hash":"8430f1b7dd243a4d99e3e0d113b5460896c1e9c8","modified":1628782351175},{"_id":"public/2021/08/12/hexo/hexo-deploy/index.html","hash":"d8dc46c2389b7e1ceeaf27969f0f3310b2fbc069","modified":1628784046356},{"_id":"public/img/blog_img/hexo.png","hash":"489eae5c8763d484d61944ab769b4e16882adadf","modified":1628773691407},{"_id":"themes/butterfly/source/img/blog_img/hexo_blog_02.png","hash":"91ecf2e95d11a738a12fb037b6cee6b98716c188","modified":1628783213410},{"_id":"themes/butterfly/source/img/blog_img/hexo_blog_01.png","hash":"ce7624c975893e1288fc22a312754561e212d30c","modified":1628782771830},{"_id":"public/img/blog_img/hexo_blog_02.png","hash":"91ecf2e95d11a738a12fb037b6cee6b98716c188","modified":1628783227977},{"_id":"public/img/blog_img/hexo_blog_01.png","hash":"ce7624c975893e1288fc22a312754561e212d30c","modified":1628783227977},{"_id":"source/_posts/hexo/hexo_blog_02.png","hash":"91ecf2e95d11a738a12fb037b6cee6b98716c188","modified":1628784011980},{"_id":"source/_posts/hexo/hexo_blog_01.png","hash":"ce7624c975893e1288fc22a312754561e212d30c","modified":1628784011650}],"Category":[{"name":"golang","_id":"cks77b4uo00046bqsdipddemf"},{"name":"博客搭建","_id":"cks7mrl460008fzo4157a846y"}],"Data":[],"Page":[{"title":"分类","date":"2021-08-10T14:38:19.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-08-10 22:38:19\ntype: \"categories\"\n---\n","updated":"2021-08-11T07:52:02.001Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cks77b4tx00006bqs484xhivx","content":"","site":{"data":{}},"cover":"http://img.mp.itc.cn/upload/20170418/9ff5d1eed5db43d59e63a88bc330556c_th.jpeg","excerpt":"","more":""},{"title":"golang learning","date":"2021-07-26T14:23:38.000Z","tags":["golang"],"_content":"","source":"golang-learning/index.md","raw":"---\ntitle: golang learning\ndate: 2021-07-26 22:23:38\ntags: [\"golang\"]\n---\n","updated":"2021-08-11T07:52:02.001Z","path":"golang-learning/index.html","comments":1,"layout":"page","_id":"cks77b4u000016bqs8a6p2s7z","content":"","site":{"data":{}},"cover":"http://img2.a0bi.com/upload/ttq/20160102/1451714325454.jpg","excerpt":"","more":""},{"title":"标签","date":"2021-08-10T13:22:51.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-08-10 21:22:51\ntype: \"tags\"\n---\n","updated":"2021-08-11T07:52:02.001Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cks77b4u100026bqs2fsvhr9k","content":"","site":{"data":{}},"cover":"http://img.mp.itc.cn/upload/20170418/9ff5d1eed5db43d59e63a88bc330556c_th.jpeg","excerpt":"","more":""}],"Post":[{"title":"Golang 常见的10种错误","sticky":1,"cover":"/img/blog_img/golang-1200x675.png","_content":"\n[原文链接](https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65#e9ba)\n\n前言：这里提到的错误，并不是那种“致命错误”，而是业务中的使用习惯的问题。如果不够了解语言的设计方式，导致使用习惯不当，可能就会引入一些设计不够好的代码。因此学习这些前人对使用方式的总结是很有帮助的。\n话不多说，一起来看看都有哪些常见易犯的错误：\n\n### 一、枚举默认值和json反序列化\n先来看一段枚举的定义：\n```\ntype Status uint32\n\nconst (\n  StatusOpen Status = iota\n  StatusClosed\n  StatusUnknown\n)\n```\n\n然后业务结构体 Request 引用了这个枚举\n```\ntype Request struct {\n  ID        int    `json:\"Id\"`\n  Timestamp int    `json:\"Timestamp\"`\n  Status    Status `json:\"Status\"`\n}\n```\n\n最后就是常见的接口之后的反序列化过程了，如果是正常的接口返回，如下：\n```\n{\n  \"Id\": 1234,\n  \"Timestamp\": 1563362390,\n  \"Status\": 0\n}\n```\n\n那么反序列化之后应该也是很正常的，调用方拿到了下游返回的状态信息，状态也都对得上。\n但是如果下游有问题，没有返回这个状态：\n```\n{\n  \"Id\": 1235,\n  \"Timestamp\": 1563362390\n}\n```\n这个时候后台拿到的状态是什么？又应该是什么？可以直接写段代码测试一下。\n\n最终：一个更健壮的枚举定义：\n```\ntype Status uint32\n\nconst (\n  StatusUnknown Status = iota\n  StatusOpen\n  StatusClosed\n)\n```\n\n别看是一个小问题，影响可不小，如果结构体设计阶段没有考虑到这个问题，需要发版之后再修复，可能要改的还有下游的结构体定义，而如果结构体是放在公共的pb 文件中，要改pb ，那么要影响到的服务可能就更多了。\n所以元数据的定义永远是基础，牵一发而动全身。设计的时候还是要更考虑周全一些。需要从 业务逻辑转换成编程思维，考虑到更多的细节。\n[参考测试代码-enum_test.go](https://github.com/smiecj/go_common_mistake/blob/master/error_test.go)\n\n### 二、BenchMarking和内联\n[参考博客-详解Go内联优化](https://segmentfault.com/a/1190000039146279)\n\n性能测试相关的代码，往往需要重复执行，如果写法不当，就很容易导致内联的问题：\n```\nfunc clear(n uint64, i, j uint8) uint64 {\n\treturn (math.MaxUint64<<j | ((1 << i) - 1)) & n\n}\n\nfunc BenchmarkCleanBit(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tclear(1221892080809121, 10, 63)\n\t}\n}\n```\n\n这里先说明一下 testing.B 这个类的功能：它表示基准测试，在测试结束之后将会输出一段性能测试的结果\n测试方法必须是 BenchMark 开头，另外执行测试需要带上 bench 参数：\n```\ngo test -bench=. benchmark_test.go\n```\n\n测试结果：\n\ngoos: windows\ngoarch: amd64\npkg: github.com/smiecj/go_common_mistake\nBenchmarkCleanBit\nBenchmarkCleanBit-8     1000000000           **0.339 ns/op**\nPASS\n\n但是接下来要说到问题了：由于 clear 方法没有执行其他方法的调用，没有边际效应，所以会被内联，再加上其返回值也没有被外层接收，所以又会被进一步优化掉，直接不会执行。所以其实测试结果是不准的。\n怎么确认 clear 方法被内联了呢？可以通过编译参数确认：\n```\ngo test -gcflags=\"-m\" -bench=. benchmark_test.go\n```\n\n> -gcflags=\"-m\": 打印编译过程中 golang 解析产生内联的详细过程\n\n\n所以验证的方式也很简单，只要避免内联就可以了。结合这个性能测试的示例，大概有两种方式：\n① 在 BenchMark 中设置一个局部变量去接收返回值\n\n② clear 方法最上面设置取消内联\n```\n//go:noinline\nfunc clear(n uint64, i, j uint8) uint64 {\n  return (math.MaxUint64<<j | ((1 << i) - 1)) & n\n}\n```\n\n新的测试结果：\ngoos: windows\ngoarch: amd64\npkg: github.com/smiecj/go_common_mistake\nBenchmarkCleanBit\nBenchmarkCleanBit-8     426727659          **2.96 ns/op**\nPASS\n\n③ 设置编译参数 -l 禁止内联\n```\ngo test -gcflags=\"-N -l -m\" -bench=. benchmark_test.go\n```\n\n> -N：禁止编译优化\n> -l：禁止内联\n\n测试结果：\ngoos: windows\ngoarch: amd64\nBenchmarkCleanBit-8     376172835                **3.13 ns/op**\nPASS\nok      command-line-arguments  2.361s\n\n扩展阅读：\n[High Performance Go Workshop](https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html)\n\n### 三、每次传参都应该用指针吗？\n首先，就传递数据量来说，指针毫无疑问，在大多数时候还是更省空间的。（64位系统中是8个字节）\n\n看起来似乎指针总比传值更好，对吧？其实不是的，我们可能只关注了参数本身的空间开销，却忽略了指针和值分别在栈和堆上的存储开销。\n先从方法的返回值去理解返回参数和返回指针的区别，来看个例子: \n```\nfunc getFooValue() foo {\n  var result foo\n  // Do something\n  return result\n}\n```\n\n方法内部新建了result对象，这个对象只可能被方法内部访问，所以这个对象分配的空间就在栈上，不会在堆上。\n然后，方法直接返回了值本身，这个动作会生成一份result的拷贝，存储在调用方的栈上，原result因为不会再被访问，将等待被GC回收。\n\n再来看返回指针的情况:\n```\nfunc main()  {\n  p := &foo{}\n  f(p)\n}\n```\n\nGo只有传值，所以对于指针p来说，它的空间申请和传递，都是和上一个例子一样的。但是对于foo对象本身，申请的时候必然不会在栈上申请，而会在堆上申请。这样才能让作用域扩大到调用方。\n\n栈比堆更快的两个原因:\n  - 栈上对象不需要GC，从上面的例子可以看到，除非返回指针，否则栈内的一切对象都跟调用方没有任何关系，都是拷贝后返回，因此可以在方法结束后直接被标记。\n  - 栈上对象只会在当前routine被使用，不需要和其他协程同步，也就不会在堆上记录任何状态信息\n\n总结来说，就是不管是传参还是返回，只要非共享的场景（当然，复合数据结构如map一般都是需要共享的），都建议传value，只有一定要传指针的时候才去传指针。\n\n扩展阅读\n[Language Mechanics On Stacks And Pointers](https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html)\n\n### 四、break和条件控制语句\n如下面这段代码，break 真的能够跳出循环吗？\n```\nfor {\n  switch f() {\n  case true:\n    break\n  case false:\n    // Do something\n  }\n}\n```\n\n答案：break 其实是跳出 switch 的循环。但是golang 的switch 执行完成一个分支之后其他分支也不会执行的，所以 switch 的 break 其实没有什么意义\n\n但是select 的break 就有意义了。所以下面这种情况也是要特别注意的，break 跳出的也不是循环\nfor {\n  select {\n  case <-ch:\n  // Do something\n  case <-ctx.Done():\n    break\n  }\n}\n\n常见的退出循环+switch的方式：break + 代码块名称\n```\nOuterLoop:\n  for i = 0; i < n; i++ {\n    for j = 0; j < m; j++ {\n      switch a[i][j] {\n      case nil:\n        state = Error\n        break OuterLoop\n      case item:\n        state = Found\n        break OuterLoop\n      }\n    }\n  }\n```\n\n### 五、错误管理\nerror的处理一般满足两个原则：处理了就不要再向上继续抛出，必须给上层返回不一样的信息；没处理就一定要继续向上抛出\n\n而go1.13之前提供的error 管理方法其实很少，所以这里我们使用 pkg/errors 这个工具来帮我们更好地管理自定义错误：\n```\nimport \"github.com/pkg/errors\"\n......\nfunc postHandler(customer Customer) Status {\n  err := insert(customer.Contract)\n  if err != nil {\n    switch errors.Cause(err).(type) {\n    default:\n      log.WithError(err).Errorf(\"unable to serve HTTP POST request for customer %s\", customer.ID)\n      return Status{ok: false}\n    case *db.DBError:\n      return retry(customer)\n    }\n\n  }\n  return Status{ok: true}\n}\n\nfunc insert(contract Contract) error {\n  err := db.dbQuery(contract)\n  if err != nil {\n    return errors.Wrapf(err, \"unable to insert customer contract %s\", contract.ID)\n  }\n  return nil\n}\n```\n\n注意到判断错误类型使用对象的type判断就可以了，**Cause**和**Wrapf**需要配套使用\n\n\n### 六、数组初始化\n#### 6.1 len 和 cap\n我们知道数组有两个初始化参数，分别表示len和cap，分别表示长度和初始化长度。\n比如初始化一个空数组：\nvar bars []Bar\nbars := make([]Bar, 0, 0)\n\n和Java不同的是，go把 cap 设置也半交给用户了（当不配置cap 的时候，len 就是 cap）。但是这也\n比如当我们把 cap 设置成负数，或者小于 len 的时候，会发生什么呢？\n直接测试一下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210718103648191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9saWl6aQ==,size_16,color_FFFFFF,t_70)\n\n可以看到编译期 就已经直接报错了，不会让你能够执行这样的代码。我们可以从types/expr.go 中找到具体报错信息打印的地方。\n\n#### 6.2 设置len 还是 cap 的效率高\n来看一种比较常见的场景：需要把数据库的对象转换成对外接口传递的对象。对象数量是确定的，需要怎么做呢？\n有两种实现方式：\n```\nfunc convert(foos []Foo) []Bar {\n  bars := make([]Bar, len(foos))\n  for i, foo := range foos {\n    bars[i] = fooToBar(foo)\n  }\n  return bars\n}\n```\n\n```\nfunc convert(foos []Foo) []Bar {\n  bars := make([]Bar, 0, len(foos))\n  for _, foo := range foos {\n    bars = append(bars, fooToBar(foo))\n  }\n  return bars\n}\n```\n\n其实两种实现方式都可以，但是前者效率显然高一些，因为空间是已经分配好的，而后者虽然cap 设定了，但是随着 不断append 元素，底层也是要不断地进行数组的拷贝的。\n\n> 译者：文章这里基本没有从源码说明效率高的原因，后续考虑新开一篇，从makeslice 方法去分析两种方式真正的差异\n\n### 七、context 管理\n#### 7.1 什么是context\n官方概念：\nA Context carries a deadline, a cancelation signal, and other values across API boundaries.\n\n这里说明了context可以带的三类信息：deadline（超时配置）、cancelation（终止动作）和values（键值对）\n\n#### 7.2 什么时候应该用context\n前两个信息是context最常用的信息和功能，最常用的场景就是rpc调用，来看看一个grpc使用示例：\n```\nctx, cancel := context.WithTimeout(parent, 100 * time.Millisecond)\nresponse, err := grpcClient.Send(ctx, request)\n```\n\nWithTimeout 方法内部就是设置了 deadline，context 将会在超时时间到来的时候触发 Done 对应的channel close。这样我们可以通过 <- context.Done) 来做一些提前结束的操作，比如释放资源，避免超时请求一直阻塞其他正常请求。\n\n总结一下，凡是涉及到上下游关系的都应该用context来处理调用关系，下游不应该忽略上游传下来的context。\n\n扩展阅读：\n[Understanding the context package in golang](http://p.agnihotry.com/post/understanding_the_context_package_in_golang/)\n\n### 八、从来不用 -race 参数\n\n根据 报告-Understanding real-world concurrency bugs in Go ，尽管go 的设计初衷是“更少错误的高并发”，但是现实中我们依然会遇到并发带来的问题\n尽管 race 检测器不一定可以检测出每一种并发错误，但是它依然是有价值的，在测试程序的过程中我们应该始终打开它。\n\n相对其余9个错误来说，竞态条件是能直接导致程序崩溃的，所以这一节应该是最重要的一部分，建议gopher 在平时开发中都尽量留意这一点，测试和调试工作要做好。\n但是 开启race 也不代表 冲突能够马上检查出来，也是要有冲突的时候，才会有Warning信息。所以建议采用线上环境留一个节点用来开启竞态检查的方式。\n\n扩展阅读：\n[Understanding real-world concurrency bugs in Go](https://blog.acolyer.org/2019/05/17/understanding-real-world-concurrency-bugs-in-go/)\n[Does the Go race detector catch all data race bugs?](https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb)\n[自己写的示例-git-race_test.go](https://github.com/smiecj/go_common_mistake/blob/master/race_test.go)\n\n\n### 九、使用文件名作为输入（方法设计不满足SOLID原则）\n#### 9.1 从问题出发\n来看一个常见的go 工具类开发需求：需要开发一个通用的读取文件行数的方法。项目中肯定会把这个方法封装到公共包的。\n一种比较直接的思路，就是设置文件名作为传参，如下：\n```\nfunc count(filename string) (int, error) {\n  file, err := os.Open(filename)\n  if err != nil {\n    return 0, errors.Wrapf(err, \"unable to open %s\", filename)\n  }\n  defer file.Close()\n\n  scanner := bufio.NewScanner(file)\n  count := 0\n  for scanner.Scan() {\n    if scanner.Text() == \"\" {\n      count++\n    }\n  }\n  return count, nil\n}\n```\n\n这种方式看上去功能没有任何问题，但是忽略了具体使用场景。如：\n- 文件编码：当然你可以让方法增加一个传参，但是不符合接下来说到的开闭原则\n- 单元测试：测试读取一个空文件场景。那么单测可能还需要先在本地创建一个空文件\n\n这些细节，都会导致这个方法看上去完美，实际使用起来限制却很多。\n\n#### 9.2 SOLID 原则\nSOLID 是面向对象编程中很重要的原则，由 总结而来。\n- S 表示  Single Responsibility （单一原则）：一个方法只做一件事\n- O 表示 open-close principle （开闭原则）：方法对扩展开放，对修改封闭\n\n从这个例子就是很好的说明：S 和 O 它实际都不满足，方法做了读取文件和扫描文件行数两件事、方法可能还需要因为文件编码做格式 做适配修改\n\n#### 9.3 优化版本\n借鉴 go 对 io.Reader 和 io.Writer 的实现思路，我们可以将传参改成这样：\n```\nfunc count(reader *bufio.Reader) (int, error) {\n  count := 0\n  for {\n    line, _, err := reader.ReadLine()\n    if err != nil {\n      switch err {\n      default:\n        return 0, errors.Wrapf(err, \"unable to read\")\n      case io.EOF:\n        return count, nil\n      }\n    }\n    if len(line) == 0 {\n      count++\n    }\n  }\n}\n```\n\n这样不仅满足和 S 和 O，方法的扩展性其实也加强了：可以读取文件流或者 http 流等的输入\n\n调用端：\n```\nfile, err := os.Open(filename)\nif err != nil {\n  return errors.Wrapf(err, \"unable to open %s\", filename)\n}\ndefer file.Close()\ncount, err := count(bufio.NewReader(file))\n```\n\n单测：读取一行字符串流\n```\ncount, err := count(bufio.NewReader(strings.NewReader(\"input\")))\n```\n\n因此，设计思想也非常重要，尽管代码规范之类的问题并不会直接导致程序运行问题，但是显然它的影响更为深远。\n\n### 十、协程和循环中的局部变量\n#### 10.1 协程共用循环的局部变量\n下面这段示例，会输出什么？\n```\nfunc TestRoutineRace(t *testing.T) {\n\tints := []int{1, 2, 3}\n\twaitGroup := sync.WaitGroup{}\n\twaitGroup.Add(len(ints))\n\n\tfor _, i := range ints {\n\t\tgo func() {\n\t\t\tfmt.Printf(\"%v\\n\", i)\n\t\t\twaitGroup.Done()\n\t\t}()\n\t}\n\twaitGroup.Wait()\n}\n```\n\n显然目的是想打印 1、2、3的，但是结果却都是3\n这是因为 子协程中，打印用的都是同一个局部变量i，这个i 在循环结束之后会变成3，所以最终打印的结果就都是3 了（大部分时候）\n\n利用刚才学的race，这种使用协程的错误方式也可以通过 -race 参数 提前检测出来。\ngo test -v **-race** routine_test.go\n检测结果：\n......\nWARNING: DATA RACE\n**Read at 0x00c000116140 by goroutine 8:**\n  command-line-arguments.TestRoutine.func1()\n      D:/coding/golang/go_common_mistake/routine_test.go:16 +0x44\n\n**Previous write at 0x00c000116140 by goroutine 7:**\n  command-line-arguments.TestRoutine()\n      D:/coding/golang/go_common_mistake/routine_test.go:14 +0x104\n  testing.tRunner()\n      G:/Program Files/Go/src/testing/testing.go:1127 +0x202\n……\n\n从错误信息可以看到，省略的部分还有其他协程，同样的警告信息。仔细分析下来就可以得到协程用的都是同一个局部变量的结论了。\n怎么样，马上就体验到 -race 参数的作用了，是不是很妙\n\n#### 10.2 避免直接使用循环中的局部变量\n对于这种情况有两种解决方法：\n1）go func 加上入参\n```\nfor _, i := range ints {\n\t\tgo func(i int) {\n\t\t\tfmt.Printf(\"%v\\n\", i)\n\t\t\twaitGroup.Done()\n\t\t}(i)\n\t}\n```\n\n2）循环内使用单独的局部变量\n![在这里插入图片描述](/img/20210718105358253.png)\n\n注意虽然这里的I 依然是局部变量，但是对每个开启的协程来说已经不是同一个了，每次进入循环的I 都是不一样的。\n但是这里我更推荐第一种写法，逻辑更加清楚\n","source":"_posts/golang/golang-mistakes.md","raw":"---\ntitle: Golang 常见的10种错误\nsticky: 1\ncover: /img/blog_img/golang-1200x675.png\ntags: ['golang']\ncategories: ['golang']\n---\n\n[原文链接](https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65#e9ba)\n\n前言：这里提到的错误，并不是那种“致命错误”，而是业务中的使用习惯的问题。如果不够了解语言的设计方式，导致使用习惯不当，可能就会引入一些设计不够好的代码。因此学习这些前人对使用方式的总结是很有帮助的。\n话不多说，一起来看看都有哪些常见易犯的错误：\n\n### 一、枚举默认值和json反序列化\n先来看一段枚举的定义：\n```\ntype Status uint32\n\nconst (\n  StatusOpen Status = iota\n  StatusClosed\n  StatusUnknown\n)\n```\n\n然后业务结构体 Request 引用了这个枚举\n```\ntype Request struct {\n  ID        int    `json:\"Id\"`\n  Timestamp int    `json:\"Timestamp\"`\n  Status    Status `json:\"Status\"`\n}\n```\n\n最后就是常见的接口之后的反序列化过程了，如果是正常的接口返回，如下：\n```\n{\n  \"Id\": 1234,\n  \"Timestamp\": 1563362390,\n  \"Status\": 0\n}\n```\n\n那么反序列化之后应该也是很正常的，调用方拿到了下游返回的状态信息，状态也都对得上。\n但是如果下游有问题，没有返回这个状态：\n```\n{\n  \"Id\": 1235,\n  \"Timestamp\": 1563362390\n}\n```\n这个时候后台拿到的状态是什么？又应该是什么？可以直接写段代码测试一下。\n\n最终：一个更健壮的枚举定义：\n```\ntype Status uint32\n\nconst (\n  StatusUnknown Status = iota\n  StatusOpen\n  StatusClosed\n)\n```\n\n别看是一个小问题，影响可不小，如果结构体设计阶段没有考虑到这个问题，需要发版之后再修复，可能要改的还有下游的结构体定义，而如果结构体是放在公共的pb 文件中，要改pb ，那么要影响到的服务可能就更多了。\n所以元数据的定义永远是基础，牵一发而动全身。设计的时候还是要更考虑周全一些。需要从 业务逻辑转换成编程思维，考虑到更多的细节。\n[参考测试代码-enum_test.go](https://github.com/smiecj/go_common_mistake/blob/master/error_test.go)\n\n### 二、BenchMarking和内联\n[参考博客-详解Go内联优化](https://segmentfault.com/a/1190000039146279)\n\n性能测试相关的代码，往往需要重复执行，如果写法不当，就很容易导致内联的问题：\n```\nfunc clear(n uint64, i, j uint8) uint64 {\n\treturn (math.MaxUint64<<j | ((1 << i) - 1)) & n\n}\n\nfunc BenchmarkCleanBit(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tclear(1221892080809121, 10, 63)\n\t}\n}\n```\n\n这里先说明一下 testing.B 这个类的功能：它表示基准测试，在测试结束之后将会输出一段性能测试的结果\n测试方法必须是 BenchMark 开头，另外执行测试需要带上 bench 参数：\n```\ngo test -bench=. benchmark_test.go\n```\n\n测试结果：\n\ngoos: windows\ngoarch: amd64\npkg: github.com/smiecj/go_common_mistake\nBenchmarkCleanBit\nBenchmarkCleanBit-8     1000000000           **0.339 ns/op**\nPASS\n\n但是接下来要说到问题了：由于 clear 方法没有执行其他方法的调用，没有边际效应，所以会被内联，再加上其返回值也没有被外层接收，所以又会被进一步优化掉，直接不会执行。所以其实测试结果是不准的。\n怎么确认 clear 方法被内联了呢？可以通过编译参数确认：\n```\ngo test -gcflags=\"-m\" -bench=. benchmark_test.go\n```\n\n> -gcflags=\"-m\": 打印编译过程中 golang 解析产生内联的详细过程\n\n\n所以验证的方式也很简单，只要避免内联就可以了。结合这个性能测试的示例，大概有两种方式：\n① 在 BenchMark 中设置一个局部变量去接收返回值\n\n② clear 方法最上面设置取消内联\n```\n//go:noinline\nfunc clear(n uint64, i, j uint8) uint64 {\n  return (math.MaxUint64<<j | ((1 << i) - 1)) & n\n}\n```\n\n新的测试结果：\ngoos: windows\ngoarch: amd64\npkg: github.com/smiecj/go_common_mistake\nBenchmarkCleanBit\nBenchmarkCleanBit-8     426727659          **2.96 ns/op**\nPASS\n\n③ 设置编译参数 -l 禁止内联\n```\ngo test -gcflags=\"-N -l -m\" -bench=. benchmark_test.go\n```\n\n> -N：禁止编译优化\n> -l：禁止内联\n\n测试结果：\ngoos: windows\ngoarch: amd64\nBenchmarkCleanBit-8     376172835                **3.13 ns/op**\nPASS\nok      command-line-arguments  2.361s\n\n扩展阅读：\n[High Performance Go Workshop](https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html)\n\n### 三、每次传参都应该用指针吗？\n首先，就传递数据量来说，指针毫无疑问，在大多数时候还是更省空间的。（64位系统中是8个字节）\n\n看起来似乎指针总比传值更好，对吧？其实不是的，我们可能只关注了参数本身的空间开销，却忽略了指针和值分别在栈和堆上的存储开销。\n先从方法的返回值去理解返回参数和返回指针的区别，来看个例子: \n```\nfunc getFooValue() foo {\n  var result foo\n  // Do something\n  return result\n}\n```\n\n方法内部新建了result对象，这个对象只可能被方法内部访问，所以这个对象分配的空间就在栈上，不会在堆上。\n然后，方法直接返回了值本身，这个动作会生成一份result的拷贝，存储在调用方的栈上，原result因为不会再被访问，将等待被GC回收。\n\n再来看返回指针的情况:\n```\nfunc main()  {\n  p := &foo{}\n  f(p)\n}\n```\n\nGo只有传值，所以对于指针p来说，它的空间申请和传递，都是和上一个例子一样的。但是对于foo对象本身，申请的时候必然不会在栈上申请，而会在堆上申请。这样才能让作用域扩大到调用方。\n\n栈比堆更快的两个原因:\n  - 栈上对象不需要GC，从上面的例子可以看到，除非返回指针，否则栈内的一切对象都跟调用方没有任何关系，都是拷贝后返回，因此可以在方法结束后直接被标记。\n  - 栈上对象只会在当前routine被使用，不需要和其他协程同步，也就不会在堆上记录任何状态信息\n\n总结来说，就是不管是传参还是返回，只要非共享的场景（当然，复合数据结构如map一般都是需要共享的），都建议传value，只有一定要传指针的时候才去传指针。\n\n扩展阅读\n[Language Mechanics On Stacks And Pointers](https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html)\n\n### 四、break和条件控制语句\n如下面这段代码，break 真的能够跳出循环吗？\n```\nfor {\n  switch f() {\n  case true:\n    break\n  case false:\n    // Do something\n  }\n}\n```\n\n答案：break 其实是跳出 switch 的循环。但是golang 的switch 执行完成一个分支之后其他分支也不会执行的，所以 switch 的 break 其实没有什么意义\n\n但是select 的break 就有意义了。所以下面这种情况也是要特别注意的，break 跳出的也不是循环\nfor {\n  select {\n  case <-ch:\n  // Do something\n  case <-ctx.Done():\n    break\n  }\n}\n\n常见的退出循环+switch的方式：break + 代码块名称\n```\nOuterLoop:\n  for i = 0; i < n; i++ {\n    for j = 0; j < m; j++ {\n      switch a[i][j] {\n      case nil:\n        state = Error\n        break OuterLoop\n      case item:\n        state = Found\n        break OuterLoop\n      }\n    }\n  }\n```\n\n### 五、错误管理\nerror的处理一般满足两个原则：处理了就不要再向上继续抛出，必须给上层返回不一样的信息；没处理就一定要继续向上抛出\n\n而go1.13之前提供的error 管理方法其实很少，所以这里我们使用 pkg/errors 这个工具来帮我们更好地管理自定义错误：\n```\nimport \"github.com/pkg/errors\"\n......\nfunc postHandler(customer Customer) Status {\n  err := insert(customer.Contract)\n  if err != nil {\n    switch errors.Cause(err).(type) {\n    default:\n      log.WithError(err).Errorf(\"unable to serve HTTP POST request for customer %s\", customer.ID)\n      return Status{ok: false}\n    case *db.DBError:\n      return retry(customer)\n    }\n\n  }\n  return Status{ok: true}\n}\n\nfunc insert(contract Contract) error {\n  err := db.dbQuery(contract)\n  if err != nil {\n    return errors.Wrapf(err, \"unable to insert customer contract %s\", contract.ID)\n  }\n  return nil\n}\n```\n\n注意到判断错误类型使用对象的type判断就可以了，**Cause**和**Wrapf**需要配套使用\n\n\n### 六、数组初始化\n#### 6.1 len 和 cap\n我们知道数组有两个初始化参数，分别表示len和cap，分别表示长度和初始化长度。\n比如初始化一个空数组：\nvar bars []Bar\nbars := make([]Bar, 0, 0)\n\n和Java不同的是，go把 cap 设置也半交给用户了（当不配置cap 的时候，len 就是 cap）。但是这也\n比如当我们把 cap 设置成负数，或者小于 len 的时候，会发生什么呢？\n直接测试一下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210718103648191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9saWl6aQ==,size_16,color_FFFFFF,t_70)\n\n可以看到编译期 就已经直接报错了，不会让你能够执行这样的代码。我们可以从types/expr.go 中找到具体报错信息打印的地方。\n\n#### 6.2 设置len 还是 cap 的效率高\n来看一种比较常见的场景：需要把数据库的对象转换成对外接口传递的对象。对象数量是确定的，需要怎么做呢？\n有两种实现方式：\n```\nfunc convert(foos []Foo) []Bar {\n  bars := make([]Bar, len(foos))\n  for i, foo := range foos {\n    bars[i] = fooToBar(foo)\n  }\n  return bars\n}\n```\n\n```\nfunc convert(foos []Foo) []Bar {\n  bars := make([]Bar, 0, len(foos))\n  for _, foo := range foos {\n    bars = append(bars, fooToBar(foo))\n  }\n  return bars\n}\n```\n\n其实两种实现方式都可以，但是前者效率显然高一些，因为空间是已经分配好的，而后者虽然cap 设定了，但是随着 不断append 元素，底层也是要不断地进行数组的拷贝的。\n\n> 译者：文章这里基本没有从源码说明效率高的原因，后续考虑新开一篇，从makeslice 方法去分析两种方式真正的差异\n\n### 七、context 管理\n#### 7.1 什么是context\n官方概念：\nA Context carries a deadline, a cancelation signal, and other values across API boundaries.\n\n这里说明了context可以带的三类信息：deadline（超时配置）、cancelation（终止动作）和values（键值对）\n\n#### 7.2 什么时候应该用context\n前两个信息是context最常用的信息和功能，最常用的场景就是rpc调用，来看看一个grpc使用示例：\n```\nctx, cancel := context.WithTimeout(parent, 100 * time.Millisecond)\nresponse, err := grpcClient.Send(ctx, request)\n```\n\nWithTimeout 方法内部就是设置了 deadline，context 将会在超时时间到来的时候触发 Done 对应的channel close。这样我们可以通过 <- context.Done) 来做一些提前结束的操作，比如释放资源，避免超时请求一直阻塞其他正常请求。\n\n总结一下，凡是涉及到上下游关系的都应该用context来处理调用关系，下游不应该忽略上游传下来的context。\n\n扩展阅读：\n[Understanding the context package in golang](http://p.agnihotry.com/post/understanding_the_context_package_in_golang/)\n\n### 八、从来不用 -race 参数\n\n根据 报告-Understanding real-world concurrency bugs in Go ，尽管go 的设计初衷是“更少错误的高并发”，但是现实中我们依然会遇到并发带来的问题\n尽管 race 检测器不一定可以检测出每一种并发错误，但是它依然是有价值的，在测试程序的过程中我们应该始终打开它。\n\n相对其余9个错误来说，竞态条件是能直接导致程序崩溃的，所以这一节应该是最重要的一部分，建议gopher 在平时开发中都尽量留意这一点，测试和调试工作要做好。\n但是 开启race 也不代表 冲突能够马上检查出来，也是要有冲突的时候，才会有Warning信息。所以建议采用线上环境留一个节点用来开启竞态检查的方式。\n\n扩展阅读：\n[Understanding real-world concurrency bugs in Go](https://blog.acolyer.org/2019/05/17/understanding-real-world-concurrency-bugs-in-go/)\n[Does the Go race detector catch all data race bugs?](https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb)\n[自己写的示例-git-race_test.go](https://github.com/smiecj/go_common_mistake/blob/master/race_test.go)\n\n\n### 九、使用文件名作为输入（方法设计不满足SOLID原则）\n#### 9.1 从问题出发\n来看一个常见的go 工具类开发需求：需要开发一个通用的读取文件行数的方法。项目中肯定会把这个方法封装到公共包的。\n一种比较直接的思路，就是设置文件名作为传参，如下：\n```\nfunc count(filename string) (int, error) {\n  file, err := os.Open(filename)\n  if err != nil {\n    return 0, errors.Wrapf(err, \"unable to open %s\", filename)\n  }\n  defer file.Close()\n\n  scanner := bufio.NewScanner(file)\n  count := 0\n  for scanner.Scan() {\n    if scanner.Text() == \"\" {\n      count++\n    }\n  }\n  return count, nil\n}\n```\n\n这种方式看上去功能没有任何问题，但是忽略了具体使用场景。如：\n- 文件编码：当然你可以让方法增加一个传参，但是不符合接下来说到的开闭原则\n- 单元测试：测试读取一个空文件场景。那么单测可能还需要先在本地创建一个空文件\n\n这些细节，都会导致这个方法看上去完美，实际使用起来限制却很多。\n\n#### 9.2 SOLID 原则\nSOLID 是面向对象编程中很重要的原则，由 总结而来。\n- S 表示  Single Responsibility （单一原则）：一个方法只做一件事\n- O 表示 open-close principle （开闭原则）：方法对扩展开放，对修改封闭\n\n从这个例子就是很好的说明：S 和 O 它实际都不满足，方法做了读取文件和扫描文件行数两件事、方法可能还需要因为文件编码做格式 做适配修改\n\n#### 9.3 优化版本\n借鉴 go 对 io.Reader 和 io.Writer 的实现思路，我们可以将传参改成这样：\n```\nfunc count(reader *bufio.Reader) (int, error) {\n  count := 0\n  for {\n    line, _, err := reader.ReadLine()\n    if err != nil {\n      switch err {\n      default:\n        return 0, errors.Wrapf(err, \"unable to read\")\n      case io.EOF:\n        return count, nil\n      }\n    }\n    if len(line) == 0 {\n      count++\n    }\n  }\n}\n```\n\n这样不仅满足和 S 和 O，方法的扩展性其实也加强了：可以读取文件流或者 http 流等的输入\n\n调用端：\n```\nfile, err := os.Open(filename)\nif err != nil {\n  return errors.Wrapf(err, \"unable to open %s\", filename)\n}\ndefer file.Close()\ncount, err := count(bufio.NewReader(file))\n```\n\n单测：读取一行字符串流\n```\ncount, err := count(bufio.NewReader(strings.NewReader(\"input\")))\n```\n\n因此，设计思想也非常重要，尽管代码规范之类的问题并不会直接导致程序运行问题，但是显然它的影响更为深远。\n\n### 十、协程和循环中的局部变量\n#### 10.1 协程共用循环的局部变量\n下面这段示例，会输出什么？\n```\nfunc TestRoutineRace(t *testing.T) {\n\tints := []int{1, 2, 3}\n\twaitGroup := sync.WaitGroup{}\n\twaitGroup.Add(len(ints))\n\n\tfor _, i := range ints {\n\t\tgo func() {\n\t\t\tfmt.Printf(\"%v\\n\", i)\n\t\t\twaitGroup.Done()\n\t\t}()\n\t}\n\twaitGroup.Wait()\n}\n```\n\n显然目的是想打印 1、2、3的，但是结果却都是3\n这是因为 子协程中，打印用的都是同一个局部变量i，这个i 在循环结束之后会变成3，所以最终打印的结果就都是3 了（大部分时候）\n\n利用刚才学的race，这种使用协程的错误方式也可以通过 -race 参数 提前检测出来。\ngo test -v **-race** routine_test.go\n检测结果：\n......\nWARNING: DATA RACE\n**Read at 0x00c000116140 by goroutine 8:**\n  command-line-arguments.TestRoutine.func1()\n      D:/coding/golang/go_common_mistake/routine_test.go:16 +0x44\n\n**Previous write at 0x00c000116140 by goroutine 7:**\n  command-line-arguments.TestRoutine()\n      D:/coding/golang/go_common_mistake/routine_test.go:14 +0x104\n  testing.tRunner()\n      G:/Program Files/Go/src/testing/testing.go:1127 +0x202\n……\n\n从错误信息可以看到，省略的部分还有其他协程，同样的警告信息。仔细分析下来就可以得到协程用的都是同一个局部变量的结论了。\n怎么样，马上就体验到 -race 参数的作用了，是不是很妙\n\n#### 10.2 避免直接使用循环中的局部变量\n对于这种情况有两种解决方法：\n1）go func 加上入参\n```\nfor _, i := range ints {\n\t\tgo func(i int) {\n\t\t\tfmt.Printf(\"%v\\n\", i)\n\t\t\twaitGroup.Done()\n\t\t}(i)\n\t}\n```\n\n2）循环内使用单独的局部变量\n![在这里插入图片描述](/img/20210718105358253.png)\n\n注意虽然这里的I 依然是局部变量，但是对每个开启的协程来说已经不是同一个了，每次进入循环的I 都是不一样的。\n但是这里我更推荐第一种写法，逻辑更加清楚\n","slug":"golang/golang-mistakes","published":1,"date":"2021-08-12T13:06:36.430Z","updated":"2021-08-11T07:52:02.000Z","_id":"cks7mylyf000gfzo471bb3gym","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65#e9ba\">原文链接</a></p>\n<p>前言：这里提到的错误，并不是那种“致命错误”，而是业务中的使用习惯的问题。如果不够了解语言的设计方式，导致使用习惯不当，可能就会引入一些设计不够好的代码。因此学习这些前人对使用方式的总结是很有帮助的。<br>话不多说，一起来看看都有哪些常见易犯的错误：</p>\n<h3 id=\"一、枚举默认值和json反序列化\"><a href=\"#一、枚举默认值和json反序列化\" class=\"headerlink\" title=\"一、枚举默认值和json反序列化\"></a>一、枚举默认值和json反序列化</h3><p>先来看一段枚举的定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Status uint32</span><br><span class=\"line\"></span><br><span class=\"line\">const (</span><br><span class=\"line\">  StatusOpen Status = iota</span><br><span class=\"line\">  StatusClosed</span><br><span class=\"line\">  StatusUnknown</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>然后业务结构体 Request 引用了这个枚举</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Request struct &#123;</span><br><span class=\"line\">  ID        int    `json:&quot;Id&quot;`</span><br><span class=\"line\">  Timestamp int    `json:&quot;Timestamp&quot;`</span><br><span class=\"line\">  Status    Status `json:&quot;Status&quot;`</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后就是常见的接口之后的反序列化过程了，如果是正常的接口返回，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;Id&quot;: 1234,</span><br><span class=\"line\">  &quot;Timestamp&quot;: 1563362390,</span><br><span class=\"line\">  &quot;Status&quot;: 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么反序列化之后应该也是很正常的，调用方拿到了下游返回的状态信息，状态也都对得上。<br>但是如果下游有问题，没有返回这个状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;Id&quot;: 1235,</span><br><span class=\"line\">  &quot;Timestamp&quot;: 1563362390</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个时候后台拿到的状态是什么？又应该是什么？可以直接写段代码测试一下。</p>\n<p>最终：一个更健壮的枚举定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Status uint32</span><br><span class=\"line\"></span><br><span class=\"line\">const (</span><br><span class=\"line\">  StatusUnknown Status = iota</span><br><span class=\"line\">  StatusOpen</span><br><span class=\"line\">  StatusClosed</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>别看是一个小问题，影响可不小，如果结构体设计阶段没有考虑到这个问题，需要发版之后再修复，可能要改的还有下游的结构体定义，而如果结构体是放在公共的pb 文件中，要改pb ，那么要影响到的服务可能就更多了。<br>所以元数据的定义永远是基础，牵一发而动全身。设计的时候还是要更考虑周全一些。需要从 业务逻辑转换成编程思维，考虑到更多的细节。<br><a href=\"https://github.com/smiecj/go_common_mistake/blob/master/error_test.go\">参考测试代码-enum_test.go</a></p>\n<h3 id=\"二、BenchMarking和内联\"><a href=\"#二、BenchMarking和内联\" class=\"headerlink\" title=\"二、BenchMarking和内联\"></a>二、BenchMarking和内联</h3><p><a href=\"https://segmentfault.com/a/1190000039146279\">参考博客-详解Go内联优化</a></p>\n<p>性能测试相关的代码，往往需要重复执行，如果写法不当，就很容易导致内联的问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func clear(n uint64, i, j uint8) uint64 &#123;</span><br><span class=\"line\">\treturn (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func BenchmarkCleanBit(b *testing.B) &#123;</span><br><span class=\"line\">\tfor i := 0; i &lt; b.N; i++ &#123;</span><br><span class=\"line\">\t\tclear(1221892080809121, 10, 63)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里先说明一下 testing.B 这个类的功能：它表示基准测试，在测试结束之后将会输出一段性能测试的结果<br>测试方法必须是 BenchMark 开头，另外执行测试需要带上 bench 参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go test -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure>\n\n<p>测试结果：</p>\n<p>goos: windows<br>goarch: amd64<br>pkg: github.com/smiecj/go_common_mistake<br>BenchmarkCleanBit<br>BenchmarkCleanBit-8     1000000000           <strong>0.339 ns/op</strong><br>PASS</p>\n<p>但是接下来要说到问题了：由于 clear 方法没有执行其他方法的调用，没有边际效应，所以会被内联，再加上其返回值也没有被外层接收，所以又会被进一步优化掉，直接不会执行。所以其实测试结果是不准的。<br>怎么确认 clear 方法被内联了呢？可以通过编译参数确认：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go test -gcflags=&quot;-m&quot; -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>-gcflags=”-m”: 打印编译过程中 golang 解析产生内联的详细过程</p>\n</blockquote>\n<p>所以验证的方式也很简单，只要避免内联就可以了。结合这个性能测试的示例，大概有两种方式：<br>① 在 BenchMark 中设置一个局部变量去接收返回值</p>\n<p>② clear 方法最上面设置取消内联</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//go:noinline</span><br><span class=\"line\">func clear(n uint64, i, j uint8) uint64 &#123;</span><br><span class=\"line\">  return (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新的测试结果：<br>goos: windows<br>goarch: amd64<br>pkg: github.com/smiecj/go_common_mistake<br>BenchmarkCleanBit<br>BenchmarkCleanBit-8     426727659          <strong>2.96 ns/op</strong><br>PASS</p>\n<p>③ 设置编译参数 -l 禁止内联</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go test -gcflags=&quot;-N -l -m&quot; -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>-N：禁止编译优化<br>-l：禁止内联</p>\n</blockquote>\n<p>测试结果：<br>goos: windows<br>goarch: amd64<br>BenchmarkCleanBit-8     376172835                <strong>3.13 ns/op</strong><br>PASS<br>ok      command-line-arguments  2.361s</p>\n<p>扩展阅读：<br><a href=\"https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html\">High Performance Go Workshop</a></p>\n<h3 id=\"三、每次传参都应该用指针吗？\"><a href=\"#三、每次传参都应该用指针吗？\" class=\"headerlink\" title=\"三、每次传参都应该用指针吗？\"></a>三、每次传参都应该用指针吗？</h3><p>首先，就传递数据量来说，指针毫无疑问，在大多数时候还是更省空间的。（64位系统中是8个字节）</p>\n<p>看起来似乎指针总比传值更好，对吧？其实不是的，我们可能只关注了参数本身的空间开销，却忽略了指针和值分别在栈和堆上的存储开销。<br>先从方法的返回值去理解返回参数和返回指针的区别，来看个例子: </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func getFooValue() foo &#123;</span><br><span class=\"line\">  var result foo</span><br><span class=\"line\">  // Do something</span><br><span class=\"line\">  return result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法内部新建了result对象，这个对象只可能被方法内部访问，所以这个对象分配的空间就在栈上，不会在堆上。<br>然后，方法直接返回了值本身，这个动作会生成一份result的拷贝，存储在调用方的栈上，原result因为不会再被访问，将等待被GC回收。</p>\n<p>再来看返回指针的情况:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()  &#123;</span><br><span class=\"line\">  p := &amp;foo&#123;&#125;</span><br><span class=\"line\">  f(p)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Go只有传值，所以对于指针p来说，它的空间申请和传递，都是和上一个例子一样的。但是对于foo对象本身，申请的时候必然不会在栈上申请，而会在堆上申请。这样才能让作用域扩大到调用方。</p>\n<p>栈比堆更快的两个原因:</p>\n<ul>\n<li>栈上对象不需要GC，从上面的例子可以看到，除非返回指针，否则栈内的一切对象都跟调用方没有任何关系，都是拷贝后返回，因此可以在方法结束后直接被标记。</li>\n<li>栈上对象只会在当前routine被使用，不需要和其他协程同步，也就不会在堆上记录任何状态信息</li>\n</ul>\n<p>总结来说，就是不管是传参还是返回，只要非共享的场景（当然，复合数据结构如map一般都是需要共享的），都建议传value，只有一定要传指针的时候才去传指针。</p>\n<p>扩展阅读<br><a href=\"https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html\">Language Mechanics On Stacks And Pointers</a></p>\n<h3 id=\"四、break和条件控制语句\"><a href=\"#四、break和条件控制语句\" class=\"headerlink\" title=\"四、break和条件控制语句\"></a>四、break和条件控制语句</h3><p>如下面这段代码，break 真的能够跳出循环吗？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for &#123;</span><br><span class=\"line\">  switch f() &#123;</span><br><span class=\"line\">  case true:</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case false:</span><br><span class=\"line\">    // Do something</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>答案：break 其实是跳出 switch 的循环。但是golang 的switch 执行完成一个分支之后其他分支也不会执行的，所以 switch 的 break 其实没有什么意义</p>\n<p>但是select 的break 就有意义了。所以下面这种情况也是要特别注意的，break 跳出的也不是循环<br>for {<br>  select {<br>  case &lt;-ch:<br>  // Do something<br>  case &lt;-ctx.Done():<br>    break<br>  }<br>}</p>\n<p>常见的退出循环+switch的方式：break + 代码块名称</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OuterLoop:</span><br><span class=\"line\">  for i = 0; i &lt; n; i++ &#123;</span><br><span class=\"line\">    for j = 0; j &lt; m; j++ &#123;</span><br><span class=\"line\">      switch a[i][j] &#123;</span><br><span class=\"line\">      case nil:</span><br><span class=\"line\">        state = Error</span><br><span class=\"line\">        break OuterLoop</span><br><span class=\"line\">      case item:</span><br><span class=\"line\">        state = Found</span><br><span class=\"line\">        break OuterLoop</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、错误管理\"><a href=\"#五、错误管理\" class=\"headerlink\" title=\"五、错误管理\"></a>五、错误管理</h3><p>error的处理一般满足两个原则：处理了就不要再向上继续抛出，必须给上层返回不一样的信息；没处理就一定要继续向上抛出</p>\n<p>而go1.13之前提供的error 管理方法其实很少，所以这里我们使用 pkg/errors 这个工具来帮我们更好地管理自定义错误：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;github.com/pkg/errors&quot;</span><br><span class=\"line\">......</span><br><span class=\"line\">func postHandler(customer Customer) Status &#123;</span><br><span class=\"line\">  err := insert(customer.Contract)</span><br><span class=\"line\">  if err != nil &#123;</span><br><span class=\"line\">    switch errors.Cause(err).(type) &#123;</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      log.WithError(err).Errorf(&quot;unable to serve HTTP POST request for customer %s&quot;, customer.ID)</span><br><span class=\"line\">      return Status&#123;ok: false&#125;</span><br><span class=\"line\">    case *db.DBError:</span><br><span class=\"line\">      return retry(customer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return Status&#123;ok: true&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func insert(contract Contract) error &#123;</span><br><span class=\"line\">  err := db.dbQuery(contract)</span><br><span class=\"line\">  if err != nil &#123;</span><br><span class=\"line\">    return errors.Wrapf(err, &quot;unable to insert customer contract %s&quot;, contract.ID)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到判断错误类型使用对象的type判断就可以了，<strong>Cause</strong>和<strong>Wrapf</strong>需要配套使用</p>\n<h3 id=\"六、数组初始化\"><a href=\"#六、数组初始化\" class=\"headerlink\" title=\"六、数组初始化\"></a>六、数组初始化</h3><h4 id=\"6-1-len-和-cap\"><a href=\"#6-1-len-和-cap\" class=\"headerlink\" title=\"6.1 len 和 cap\"></a>6.1 len 和 cap</h4><p>我们知道数组有两个初始化参数，分别表示len和cap，分别表示长度和初始化长度。<br>比如初始化一个空数组：<br>var bars []Bar<br>bars := make([]Bar, 0, 0)</p>\n<p>和Java不同的是，go把 cap 设置也半交给用户了（当不配置cap 的时候，len 就是 cap）。但是这也<br>比如当我们把 cap 设置成负数，或者小于 len 的时候，会发生什么呢？<br>直接测试一下：<br><img src=\"https://img-blog.csdnimg.cn/20210718103648191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9saWl6aQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>可以看到编译期 就已经直接报错了，不会让你能够执行这样的代码。我们可以从types/expr.go 中找到具体报错信息打印的地方。</p>\n<h4 id=\"6-2-设置len-还是-cap-的效率高\"><a href=\"#6-2-设置len-还是-cap-的效率高\" class=\"headerlink\" title=\"6.2 设置len 还是 cap 的效率高\"></a>6.2 设置len 还是 cap 的效率高</h4><p>来看一种比较常见的场景：需要把数据库的对象转换成对外接口传递的对象。对象数量是确定的，需要怎么做呢？<br>有两种实现方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func convert(foos []Foo) []Bar &#123;</span><br><span class=\"line\">  bars := make([]Bar, len(foos))</span><br><span class=\"line\">  for i, foo := range foos &#123;</span><br><span class=\"line\">    bars[i] = fooToBar(foo)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return bars</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func convert(foos []Foo) []Bar &#123;</span><br><span class=\"line\">  bars := make([]Bar, 0, len(foos))</span><br><span class=\"line\">  for _, foo := range foos &#123;</span><br><span class=\"line\">    bars = append(bars, fooToBar(foo))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return bars</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实两种实现方式都可以，但是前者效率显然高一些，因为空间是已经分配好的，而后者虽然cap 设定了，但是随着 不断append 元素，底层也是要不断地进行数组的拷贝的。</p>\n<blockquote>\n<p>译者：文章这里基本没有从源码说明效率高的原因，后续考虑新开一篇，从makeslice 方法去分析两种方式真正的差异</p>\n</blockquote>\n<h3 id=\"七、context-管理\"><a href=\"#七、context-管理\" class=\"headerlink\" title=\"七、context 管理\"></a>七、context 管理</h3><h4 id=\"7-1-什么是context\"><a href=\"#7-1-什么是context\" class=\"headerlink\" title=\"7.1 什么是context\"></a>7.1 什么是context</h4><p>官方概念：<br>A Context carries a deadline, a cancelation signal, and other values across API boundaries.</p>\n<p>这里说明了context可以带的三类信息：deadline（超时配置）、cancelation（终止动作）和values（键值对）</p>\n<h4 id=\"7-2-什么时候应该用context\"><a href=\"#7-2-什么时候应该用context\" class=\"headerlink\" title=\"7.2 什么时候应该用context\"></a>7.2 什么时候应该用context</h4><p>前两个信息是context最常用的信息和功能，最常用的场景就是rpc调用，来看看一个grpc使用示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx, cancel := context.WithTimeout(parent, 100 * time.Millisecond)</span><br><span class=\"line\">response, err := grpcClient.Send(ctx, request)</span><br></pre></td></tr></table></figure>\n\n<p>WithTimeout 方法内部就是设置了 deadline，context 将会在超时时间到来的时候触发 Done 对应的channel close。这样我们可以通过 &lt;- context.Done) 来做一些提前结束的操作，比如释放资源，避免超时请求一直阻塞其他正常请求。</p>\n<p>总结一下，凡是涉及到上下游关系的都应该用context来处理调用关系，下游不应该忽略上游传下来的context。</p>\n<p>扩展阅读：<br><a href=\"http://p.agnihotry.com/post/understanding_the_context_package_in_golang/\">Understanding the context package in golang</a></p>\n<h3 id=\"八、从来不用-race-参数\"><a href=\"#八、从来不用-race-参数\" class=\"headerlink\" title=\"八、从来不用 -race 参数\"></a>八、从来不用 -race 参数</h3><p>根据 报告-Understanding real-world concurrency bugs in Go ，尽管go 的设计初衷是“更少错误的高并发”，但是现实中我们依然会遇到并发带来的问题<br>尽管 race 检测器不一定可以检测出每一种并发错误，但是它依然是有价值的，在测试程序的过程中我们应该始终打开它。</p>\n<p>相对其余9个错误来说，竞态条件是能直接导致程序崩溃的，所以这一节应该是最重要的一部分，建议gopher 在平时开发中都尽量留意这一点，测试和调试工作要做好。<br>但是 开启race 也不代表 冲突能够马上检查出来，也是要有冲突的时候，才会有Warning信息。所以建议采用线上环境留一个节点用来开启竞态检查的方式。</p>\n<p>扩展阅读：<br><a href=\"https://blog.acolyer.org/2019/05/17/understanding-real-world-concurrency-bugs-in-go/\">Understanding real-world concurrency bugs in Go</a><br><a href=\"https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb\">Does the Go race detector catch all data race bugs?</a><br><a href=\"https://github.com/smiecj/go_common_mistake/blob/master/race_test.go\">自己写的示例-git-race_test.go</a></p>\n<h3 id=\"九、使用文件名作为输入（方法设计不满足SOLID原则）\"><a href=\"#九、使用文件名作为输入（方法设计不满足SOLID原则）\" class=\"headerlink\" title=\"九、使用文件名作为输入（方法设计不满足SOLID原则）\"></a>九、使用文件名作为输入（方法设计不满足SOLID原则）</h3><h4 id=\"9-1-从问题出发\"><a href=\"#9-1-从问题出发\" class=\"headerlink\" title=\"9.1 从问题出发\"></a>9.1 从问题出发</h4><p>来看一个常见的go 工具类开发需求：需要开发一个通用的读取文件行数的方法。项目中肯定会把这个方法封装到公共包的。<br>一种比较直接的思路，就是设置文件名作为传参，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func count(filename string) (int, error) &#123;</span><br><span class=\"line\">  file, err := os.Open(filename)</span><br><span class=\"line\">  if err != nil &#123;</span><br><span class=\"line\">    return 0, errors.Wrapf(err, &quot;unable to open %s&quot;, filename)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  defer file.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">  scanner := bufio.NewScanner(file)</span><br><span class=\"line\">  count := 0</span><br><span class=\"line\">  for scanner.Scan() &#123;</span><br><span class=\"line\">    if scanner.Text() == &quot;&quot; &#123;</span><br><span class=\"line\">      count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return count, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式看上去功能没有任何问题，但是忽略了具体使用场景。如：</p>\n<ul>\n<li>文件编码：当然你可以让方法增加一个传参，但是不符合接下来说到的开闭原则</li>\n<li>单元测试：测试读取一个空文件场景。那么单测可能还需要先在本地创建一个空文件</li>\n</ul>\n<p>这些细节，都会导致这个方法看上去完美，实际使用起来限制却很多。</p>\n<h4 id=\"9-2-SOLID-原则\"><a href=\"#9-2-SOLID-原则\" class=\"headerlink\" title=\"9.2 SOLID 原则\"></a>9.2 SOLID 原则</h4><p>SOLID 是面向对象编程中很重要的原则，由 总结而来。</p>\n<ul>\n<li>S 表示  Single Responsibility （单一原则）：一个方法只做一件事</li>\n<li>O 表示 open-close principle （开闭原则）：方法对扩展开放，对修改封闭</li>\n</ul>\n<p>从这个例子就是很好的说明：S 和 O 它实际都不满足，方法做了读取文件和扫描文件行数两件事、方法可能还需要因为文件编码做格式 做适配修改</p>\n<h4 id=\"9-3-优化版本\"><a href=\"#9-3-优化版本\" class=\"headerlink\" title=\"9.3 优化版本\"></a>9.3 优化版本</h4><p>借鉴 go 对 io.Reader 和 io.Writer 的实现思路，我们可以将传参改成这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func count(reader *bufio.Reader) (int, error) &#123;</span><br><span class=\"line\">  count := 0</span><br><span class=\"line\">  for &#123;</span><br><span class=\"line\">    line, _, err := reader.ReadLine()</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">      switch err &#123;</span><br><span class=\"line\">      default:</span><br><span class=\"line\">        return 0, errors.Wrapf(err, &quot;unable to read&quot;)</span><br><span class=\"line\">      case io.EOF:</span><br><span class=\"line\">        return count, nil</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if len(line) == 0 &#123;</span><br><span class=\"line\">      count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样不仅满足和 S 和 O，方法的扩展性其实也加强了：可以读取文件流或者 http 流等的输入</p>\n<p>调用端：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Open(filename)</span><br><span class=\"line\">if err != nil &#123;</span><br><span class=\"line\">  return errors.Wrapf(err, &quot;unable to open %s&quot;, filename)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">defer file.Close()</span><br><span class=\"line\">count, err := count(bufio.NewReader(file))</span><br></pre></td></tr></table></figure>\n\n<p>单测：读取一行字符串流</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count, err := count(bufio.NewReader(strings.NewReader(&quot;input&quot;)))</span><br></pre></td></tr></table></figure>\n\n<p>因此，设计思想也非常重要，尽管代码规范之类的问题并不会直接导致程序运行问题，但是显然它的影响更为深远。</p>\n<h3 id=\"十、协程和循环中的局部变量\"><a href=\"#十、协程和循环中的局部变量\" class=\"headerlink\" title=\"十、协程和循环中的局部变量\"></a>十、协程和循环中的局部变量</h3><h4 id=\"10-1-协程共用循环的局部变量\"><a href=\"#10-1-协程共用循环的局部变量\" class=\"headerlink\" title=\"10.1 协程共用循环的局部变量\"></a>10.1 协程共用循环的局部变量</h4><p>下面这段示例，会输出什么？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func TestRoutineRace(t *testing.T) &#123;</span><br><span class=\"line\">\tints := []int&#123;1, 2, 3&#125;</span><br><span class=\"line\">\twaitGroup := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">\twaitGroup.Add(len(ints))</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor _, i := range ints &#123;</span><br><span class=\"line\">\t\tgo func() &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(&quot;%v\\n&quot;, i)</span><br><span class=\"line\">\t\t\twaitGroup.Done()</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twaitGroup.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显然目的是想打印 1、2、3的，但是结果却都是3<br>这是因为 子协程中，打印用的都是同一个局部变量i，这个i 在循环结束之后会变成3，所以最终打印的结果就都是3 了（大部分时候）</p>\n<p>利用刚才学的race，这种使用协程的错误方式也可以通过 -race 参数 提前检测出来。<br>go test -v <strong>-race</strong> routine_test.go<br>检测结果：<br>……<br>WARNING: DATA RACE<br><strong>Read at 0x00c000116140 by goroutine 8:</strong><br>  command-line-arguments.TestRoutine.func1()<br>      D:/coding/golang/go_common_mistake/routine_test.go:16 +0x44</p>\n<p><strong>Previous write at 0x00c000116140 by goroutine 7:</strong><br>  command-line-arguments.TestRoutine()<br>      D:/coding/golang/go_common_mistake/routine_test.go:14 +0x104<br>  testing.tRunner()<br>      G:/Program Files/Go/src/testing/testing.go:1127 +0x202<br>……</p>\n<p>从错误信息可以看到，省略的部分还有其他协程，同样的警告信息。仔细分析下来就可以得到协程用的都是同一个局部变量的结论了。<br>怎么样，马上就体验到 -race 参数的作用了，是不是很妙</p>\n<h4 id=\"10-2-避免直接使用循环中的局部变量\"><a href=\"#10-2-避免直接使用循环中的局部变量\" class=\"headerlink\" title=\"10.2 避免直接使用循环中的局部变量\"></a>10.2 避免直接使用循环中的局部变量</h4><p>对于这种情况有两种解决方法：<br>1）go func 加上入参</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for _, i := range ints &#123;</span><br><span class=\"line\">\t\tgo func(i int) &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(&quot;%v\\n&quot;, i)</span><br><span class=\"line\">\t\t\twaitGroup.Done()</span><br><span class=\"line\">\t\t&#125;(i)</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2）循环内使用单独的局部变量<br><img src=\"/img/20210718105358253.png\" alt=\"在这里插入图片描述\"></p>\n<p>注意虽然这里的I 依然是局部变量，但是对每个开启的协程来说已经不是同一个了，每次进入循环的I 都是不一样的。<br>但是这里我更推荐第一种写法，逻辑更加清楚</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65#e9ba\">原文链接</a></p>\n<p>前言：这里提到的错误，并不是那种“致命错误”，而是业务中的使用习惯的问题。如果不够了解语言的设计方式，导致使用习惯不当，可能就会引入一些设计不够好的代码。因此学习这些前人对使用方式的总结是很有帮助的。<br>话不多说，一起来看看都有哪些常见易犯的错误：</p>\n<h3 id=\"一、枚举默认值和json反序列化\"><a href=\"#一、枚举默认值和json反序列化\" class=\"headerlink\" title=\"一、枚举默认值和json反序列化\"></a>一、枚举默认值和json反序列化</h3><p>先来看一段枚举的定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Status uint32</span><br><span class=\"line\"></span><br><span class=\"line\">const (</span><br><span class=\"line\">  StatusOpen Status = iota</span><br><span class=\"line\">  StatusClosed</span><br><span class=\"line\">  StatusUnknown</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>然后业务结构体 Request 引用了这个枚举</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Request struct &#123;</span><br><span class=\"line\">  ID        int    `json:&quot;Id&quot;`</span><br><span class=\"line\">  Timestamp int    `json:&quot;Timestamp&quot;`</span><br><span class=\"line\">  Status    Status `json:&quot;Status&quot;`</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后就是常见的接口之后的反序列化过程了，如果是正常的接口返回，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;Id&quot;: 1234,</span><br><span class=\"line\">  &quot;Timestamp&quot;: 1563362390,</span><br><span class=\"line\">  &quot;Status&quot;: 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么反序列化之后应该也是很正常的，调用方拿到了下游返回的状态信息，状态也都对得上。<br>但是如果下游有问题，没有返回这个状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;Id&quot;: 1235,</span><br><span class=\"line\">  &quot;Timestamp&quot;: 1563362390</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个时候后台拿到的状态是什么？又应该是什么？可以直接写段代码测试一下。</p>\n<p>最终：一个更健壮的枚举定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Status uint32</span><br><span class=\"line\"></span><br><span class=\"line\">const (</span><br><span class=\"line\">  StatusUnknown Status = iota</span><br><span class=\"line\">  StatusOpen</span><br><span class=\"line\">  StatusClosed</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>别看是一个小问题，影响可不小，如果结构体设计阶段没有考虑到这个问题，需要发版之后再修复，可能要改的还有下游的结构体定义，而如果结构体是放在公共的pb 文件中，要改pb ，那么要影响到的服务可能就更多了。<br>所以元数据的定义永远是基础，牵一发而动全身。设计的时候还是要更考虑周全一些。需要从 业务逻辑转换成编程思维，考虑到更多的细节。<br><a href=\"https://github.com/smiecj/go_common_mistake/blob/master/error_test.go\">参考测试代码-enum_test.go</a></p>\n<h3 id=\"二、BenchMarking和内联\"><a href=\"#二、BenchMarking和内联\" class=\"headerlink\" title=\"二、BenchMarking和内联\"></a>二、BenchMarking和内联</h3><p><a href=\"https://segmentfault.com/a/1190000039146279\">参考博客-详解Go内联优化</a></p>\n<p>性能测试相关的代码，往往需要重复执行，如果写法不当，就很容易导致内联的问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func clear(n uint64, i, j uint8) uint64 &#123;</span><br><span class=\"line\">\treturn (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func BenchmarkCleanBit(b *testing.B) &#123;</span><br><span class=\"line\">\tfor i := 0; i &lt; b.N; i++ &#123;</span><br><span class=\"line\">\t\tclear(1221892080809121, 10, 63)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里先说明一下 testing.B 这个类的功能：它表示基准测试，在测试结束之后将会输出一段性能测试的结果<br>测试方法必须是 BenchMark 开头，另外执行测试需要带上 bench 参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go test -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure>\n\n<p>测试结果：</p>\n<p>goos: windows<br>goarch: amd64<br>pkg: github.com/smiecj/go_common_mistake<br>BenchmarkCleanBit<br>BenchmarkCleanBit-8     1000000000           <strong>0.339 ns/op</strong><br>PASS</p>\n<p>但是接下来要说到问题了：由于 clear 方法没有执行其他方法的调用，没有边际效应，所以会被内联，再加上其返回值也没有被外层接收，所以又会被进一步优化掉，直接不会执行。所以其实测试结果是不准的。<br>怎么确认 clear 方法被内联了呢？可以通过编译参数确认：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go test -gcflags=&quot;-m&quot; -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>-gcflags=”-m”: 打印编译过程中 golang 解析产生内联的详细过程</p>\n</blockquote>\n<p>所以验证的方式也很简单，只要避免内联就可以了。结合这个性能测试的示例，大概有两种方式：<br>① 在 BenchMark 中设置一个局部变量去接收返回值</p>\n<p>② clear 方法最上面设置取消内联</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//go:noinline</span><br><span class=\"line\">func clear(n uint64, i, j uint8) uint64 &#123;</span><br><span class=\"line\">  return (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新的测试结果：<br>goos: windows<br>goarch: amd64<br>pkg: github.com/smiecj/go_common_mistake<br>BenchmarkCleanBit<br>BenchmarkCleanBit-8     426727659          <strong>2.96 ns/op</strong><br>PASS</p>\n<p>③ 设置编译参数 -l 禁止内联</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go test -gcflags=&quot;-N -l -m&quot; -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>-N：禁止编译优化<br>-l：禁止内联</p>\n</blockquote>\n<p>测试结果：<br>goos: windows<br>goarch: amd64<br>BenchmarkCleanBit-8     376172835                <strong>3.13 ns/op</strong><br>PASS<br>ok      command-line-arguments  2.361s</p>\n<p>扩展阅读：<br><a href=\"https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html\">High Performance Go Workshop</a></p>\n<h3 id=\"三、每次传参都应该用指针吗？\"><a href=\"#三、每次传参都应该用指针吗？\" class=\"headerlink\" title=\"三、每次传参都应该用指针吗？\"></a>三、每次传参都应该用指针吗？</h3><p>首先，就传递数据量来说，指针毫无疑问，在大多数时候还是更省空间的。（64位系统中是8个字节）</p>\n<p>看起来似乎指针总比传值更好，对吧？其实不是的，我们可能只关注了参数本身的空间开销，却忽略了指针和值分别在栈和堆上的存储开销。<br>先从方法的返回值去理解返回参数和返回指针的区别，来看个例子: </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func getFooValue() foo &#123;</span><br><span class=\"line\">  var result foo</span><br><span class=\"line\">  // Do something</span><br><span class=\"line\">  return result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法内部新建了result对象，这个对象只可能被方法内部访问，所以这个对象分配的空间就在栈上，不会在堆上。<br>然后，方法直接返回了值本身，这个动作会生成一份result的拷贝，存储在调用方的栈上，原result因为不会再被访问，将等待被GC回收。</p>\n<p>再来看返回指针的情况:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main()  &#123;</span><br><span class=\"line\">  p := &amp;foo&#123;&#125;</span><br><span class=\"line\">  f(p)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Go只有传值，所以对于指针p来说，它的空间申请和传递，都是和上一个例子一样的。但是对于foo对象本身，申请的时候必然不会在栈上申请，而会在堆上申请。这样才能让作用域扩大到调用方。</p>\n<p>栈比堆更快的两个原因:</p>\n<ul>\n<li>栈上对象不需要GC，从上面的例子可以看到，除非返回指针，否则栈内的一切对象都跟调用方没有任何关系，都是拷贝后返回，因此可以在方法结束后直接被标记。</li>\n<li>栈上对象只会在当前routine被使用，不需要和其他协程同步，也就不会在堆上记录任何状态信息</li>\n</ul>\n<p>总结来说，就是不管是传参还是返回，只要非共享的场景（当然，复合数据结构如map一般都是需要共享的），都建议传value，只有一定要传指针的时候才去传指针。</p>\n<p>扩展阅读<br><a href=\"https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html\">Language Mechanics On Stacks And Pointers</a></p>\n<h3 id=\"四、break和条件控制语句\"><a href=\"#四、break和条件控制语句\" class=\"headerlink\" title=\"四、break和条件控制语句\"></a>四、break和条件控制语句</h3><p>如下面这段代码，break 真的能够跳出循环吗？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for &#123;</span><br><span class=\"line\">  switch f() &#123;</span><br><span class=\"line\">  case true:</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case false:</span><br><span class=\"line\">    // Do something</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>答案：break 其实是跳出 switch 的循环。但是golang 的switch 执行完成一个分支之后其他分支也不会执行的，所以 switch 的 break 其实没有什么意义</p>\n<p>但是select 的break 就有意义了。所以下面这种情况也是要特别注意的，break 跳出的也不是循环<br>for {<br>  select {<br>  case &lt;-ch:<br>  // Do something<br>  case &lt;-ctx.Done():<br>    break<br>  }<br>}</p>\n<p>常见的退出循环+switch的方式：break + 代码块名称</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OuterLoop:</span><br><span class=\"line\">  for i = 0; i &lt; n; i++ &#123;</span><br><span class=\"line\">    for j = 0; j &lt; m; j++ &#123;</span><br><span class=\"line\">      switch a[i][j] &#123;</span><br><span class=\"line\">      case nil:</span><br><span class=\"line\">        state = Error</span><br><span class=\"line\">        break OuterLoop</span><br><span class=\"line\">      case item:</span><br><span class=\"line\">        state = Found</span><br><span class=\"line\">        break OuterLoop</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、错误管理\"><a href=\"#五、错误管理\" class=\"headerlink\" title=\"五、错误管理\"></a>五、错误管理</h3><p>error的处理一般满足两个原则：处理了就不要再向上继续抛出，必须给上层返回不一样的信息；没处理就一定要继续向上抛出</p>\n<p>而go1.13之前提供的error 管理方法其实很少，所以这里我们使用 pkg/errors 这个工具来帮我们更好地管理自定义错误：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;github.com/pkg/errors&quot;</span><br><span class=\"line\">......</span><br><span class=\"line\">func postHandler(customer Customer) Status &#123;</span><br><span class=\"line\">  err := insert(customer.Contract)</span><br><span class=\"line\">  if err != nil &#123;</span><br><span class=\"line\">    switch errors.Cause(err).(type) &#123;</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      log.WithError(err).Errorf(&quot;unable to serve HTTP POST request for customer %s&quot;, customer.ID)</span><br><span class=\"line\">      return Status&#123;ok: false&#125;</span><br><span class=\"line\">    case *db.DBError:</span><br><span class=\"line\">      return retry(customer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return Status&#123;ok: true&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func insert(contract Contract) error &#123;</span><br><span class=\"line\">  err := db.dbQuery(contract)</span><br><span class=\"line\">  if err != nil &#123;</span><br><span class=\"line\">    return errors.Wrapf(err, &quot;unable to insert customer contract %s&quot;, contract.ID)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到判断错误类型使用对象的type判断就可以了，<strong>Cause</strong>和<strong>Wrapf</strong>需要配套使用</p>\n<h3 id=\"六、数组初始化\"><a href=\"#六、数组初始化\" class=\"headerlink\" title=\"六、数组初始化\"></a>六、数组初始化</h3><h4 id=\"6-1-len-和-cap\"><a href=\"#6-1-len-和-cap\" class=\"headerlink\" title=\"6.1 len 和 cap\"></a>6.1 len 和 cap</h4><p>我们知道数组有两个初始化参数，分别表示len和cap，分别表示长度和初始化长度。<br>比如初始化一个空数组：<br>var bars []Bar<br>bars := make([]Bar, 0, 0)</p>\n<p>和Java不同的是，go把 cap 设置也半交给用户了（当不配置cap 的时候，len 就是 cap）。但是这也<br>比如当我们把 cap 设置成负数，或者小于 len 的时候，会发生什么呢？<br>直接测试一下：<br><img src=\"https://img-blog.csdnimg.cn/20210718103648191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9saWl6aQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>可以看到编译期 就已经直接报错了，不会让你能够执行这样的代码。我们可以从types/expr.go 中找到具体报错信息打印的地方。</p>\n<h4 id=\"6-2-设置len-还是-cap-的效率高\"><a href=\"#6-2-设置len-还是-cap-的效率高\" class=\"headerlink\" title=\"6.2 设置len 还是 cap 的效率高\"></a>6.2 设置len 还是 cap 的效率高</h4><p>来看一种比较常见的场景：需要把数据库的对象转换成对外接口传递的对象。对象数量是确定的，需要怎么做呢？<br>有两种实现方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func convert(foos []Foo) []Bar &#123;</span><br><span class=\"line\">  bars := make([]Bar, len(foos))</span><br><span class=\"line\">  for i, foo := range foos &#123;</span><br><span class=\"line\">    bars[i] = fooToBar(foo)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return bars</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func convert(foos []Foo) []Bar &#123;</span><br><span class=\"line\">  bars := make([]Bar, 0, len(foos))</span><br><span class=\"line\">  for _, foo := range foos &#123;</span><br><span class=\"line\">    bars = append(bars, fooToBar(foo))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return bars</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实两种实现方式都可以，但是前者效率显然高一些，因为空间是已经分配好的，而后者虽然cap 设定了，但是随着 不断append 元素，底层也是要不断地进行数组的拷贝的。</p>\n<blockquote>\n<p>译者：文章这里基本没有从源码说明效率高的原因，后续考虑新开一篇，从makeslice 方法去分析两种方式真正的差异</p>\n</blockquote>\n<h3 id=\"七、context-管理\"><a href=\"#七、context-管理\" class=\"headerlink\" title=\"七、context 管理\"></a>七、context 管理</h3><h4 id=\"7-1-什么是context\"><a href=\"#7-1-什么是context\" class=\"headerlink\" title=\"7.1 什么是context\"></a>7.1 什么是context</h4><p>官方概念：<br>A Context carries a deadline, a cancelation signal, and other values across API boundaries.</p>\n<p>这里说明了context可以带的三类信息：deadline（超时配置）、cancelation（终止动作）和values（键值对）</p>\n<h4 id=\"7-2-什么时候应该用context\"><a href=\"#7-2-什么时候应该用context\" class=\"headerlink\" title=\"7.2 什么时候应该用context\"></a>7.2 什么时候应该用context</h4><p>前两个信息是context最常用的信息和功能，最常用的场景就是rpc调用，来看看一个grpc使用示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx, cancel := context.WithTimeout(parent, 100 * time.Millisecond)</span><br><span class=\"line\">response, err := grpcClient.Send(ctx, request)</span><br></pre></td></tr></table></figure>\n\n<p>WithTimeout 方法内部就是设置了 deadline，context 将会在超时时间到来的时候触发 Done 对应的channel close。这样我们可以通过 &lt;- context.Done) 来做一些提前结束的操作，比如释放资源，避免超时请求一直阻塞其他正常请求。</p>\n<p>总结一下，凡是涉及到上下游关系的都应该用context来处理调用关系，下游不应该忽略上游传下来的context。</p>\n<p>扩展阅读：<br><a href=\"http://p.agnihotry.com/post/understanding_the_context_package_in_golang/\">Understanding the context package in golang</a></p>\n<h3 id=\"八、从来不用-race-参数\"><a href=\"#八、从来不用-race-参数\" class=\"headerlink\" title=\"八、从来不用 -race 参数\"></a>八、从来不用 -race 参数</h3><p>根据 报告-Understanding real-world concurrency bugs in Go ，尽管go 的设计初衷是“更少错误的高并发”，但是现实中我们依然会遇到并发带来的问题<br>尽管 race 检测器不一定可以检测出每一种并发错误，但是它依然是有价值的，在测试程序的过程中我们应该始终打开它。</p>\n<p>相对其余9个错误来说，竞态条件是能直接导致程序崩溃的，所以这一节应该是最重要的一部分，建议gopher 在平时开发中都尽量留意这一点，测试和调试工作要做好。<br>但是 开启race 也不代表 冲突能够马上检查出来，也是要有冲突的时候，才会有Warning信息。所以建议采用线上环境留一个节点用来开启竞态检查的方式。</p>\n<p>扩展阅读：<br><a href=\"https://blog.acolyer.org/2019/05/17/understanding-real-world-concurrency-bugs-in-go/\">Understanding real-world concurrency bugs in Go</a><br><a href=\"https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb\">Does the Go race detector catch all data race bugs?</a><br><a href=\"https://github.com/smiecj/go_common_mistake/blob/master/race_test.go\">自己写的示例-git-race_test.go</a></p>\n<h3 id=\"九、使用文件名作为输入（方法设计不满足SOLID原则）\"><a href=\"#九、使用文件名作为输入（方法设计不满足SOLID原则）\" class=\"headerlink\" title=\"九、使用文件名作为输入（方法设计不满足SOLID原则）\"></a>九、使用文件名作为输入（方法设计不满足SOLID原则）</h3><h4 id=\"9-1-从问题出发\"><a href=\"#9-1-从问题出发\" class=\"headerlink\" title=\"9.1 从问题出发\"></a>9.1 从问题出发</h4><p>来看一个常见的go 工具类开发需求：需要开发一个通用的读取文件行数的方法。项目中肯定会把这个方法封装到公共包的。<br>一种比较直接的思路，就是设置文件名作为传参，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func count(filename string) (int, error) &#123;</span><br><span class=\"line\">  file, err := os.Open(filename)</span><br><span class=\"line\">  if err != nil &#123;</span><br><span class=\"line\">    return 0, errors.Wrapf(err, &quot;unable to open %s&quot;, filename)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  defer file.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">  scanner := bufio.NewScanner(file)</span><br><span class=\"line\">  count := 0</span><br><span class=\"line\">  for scanner.Scan() &#123;</span><br><span class=\"line\">    if scanner.Text() == &quot;&quot; &#123;</span><br><span class=\"line\">      count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return count, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式看上去功能没有任何问题，但是忽略了具体使用场景。如：</p>\n<ul>\n<li>文件编码：当然你可以让方法增加一个传参，但是不符合接下来说到的开闭原则</li>\n<li>单元测试：测试读取一个空文件场景。那么单测可能还需要先在本地创建一个空文件</li>\n</ul>\n<p>这些细节，都会导致这个方法看上去完美，实际使用起来限制却很多。</p>\n<h4 id=\"9-2-SOLID-原则\"><a href=\"#9-2-SOLID-原则\" class=\"headerlink\" title=\"9.2 SOLID 原则\"></a>9.2 SOLID 原则</h4><p>SOLID 是面向对象编程中很重要的原则，由 总结而来。</p>\n<ul>\n<li>S 表示  Single Responsibility （单一原则）：一个方法只做一件事</li>\n<li>O 表示 open-close principle （开闭原则）：方法对扩展开放，对修改封闭</li>\n</ul>\n<p>从这个例子就是很好的说明：S 和 O 它实际都不满足，方法做了读取文件和扫描文件行数两件事、方法可能还需要因为文件编码做格式 做适配修改</p>\n<h4 id=\"9-3-优化版本\"><a href=\"#9-3-优化版本\" class=\"headerlink\" title=\"9.3 优化版本\"></a>9.3 优化版本</h4><p>借鉴 go 对 io.Reader 和 io.Writer 的实现思路，我们可以将传参改成这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func count(reader *bufio.Reader) (int, error) &#123;</span><br><span class=\"line\">  count := 0</span><br><span class=\"line\">  for &#123;</span><br><span class=\"line\">    line, _, err := reader.ReadLine()</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">      switch err &#123;</span><br><span class=\"line\">      default:</span><br><span class=\"line\">        return 0, errors.Wrapf(err, &quot;unable to read&quot;)</span><br><span class=\"line\">      case io.EOF:</span><br><span class=\"line\">        return count, nil</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if len(line) == 0 &#123;</span><br><span class=\"line\">      count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样不仅满足和 S 和 O，方法的扩展性其实也加强了：可以读取文件流或者 http 流等的输入</p>\n<p>调用端：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Open(filename)</span><br><span class=\"line\">if err != nil &#123;</span><br><span class=\"line\">  return errors.Wrapf(err, &quot;unable to open %s&quot;, filename)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">defer file.Close()</span><br><span class=\"line\">count, err := count(bufio.NewReader(file))</span><br></pre></td></tr></table></figure>\n\n<p>单测：读取一行字符串流</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count, err := count(bufio.NewReader(strings.NewReader(&quot;input&quot;)))</span><br></pre></td></tr></table></figure>\n\n<p>因此，设计思想也非常重要，尽管代码规范之类的问题并不会直接导致程序运行问题，但是显然它的影响更为深远。</p>\n<h3 id=\"十、协程和循环中的局部变量\"><a href=\"#十、协程和循环中的局部变量\" class=\"headerlink\" title=\"十、协程和循环中的局部变量\"></a>十、协程和循环中的局部变量</h3><h4 id=\"10-1-协程共用循环的局部变量\"><a href=\"#10-1-协程共用循环的局部变量\" class=\"headerlink\" title=\"10.1 协程共用循环的局部变量\"></a>10.1 协程共用循环的局部变量</h4><p>下面这段示例，会输出什么？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func TestRoutineRace(t *testing.T) &#123;</span><br><span class=\"line\">\tints := []int&#123;1, 2, 3&#125;</span><br><span class=\"line\">\twaitGroup := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">\twaitGroup.Add(len(ints))</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor _, i := range ints &#123;</span><br><span class=\"line\">\t\tgo func() &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(&quot;%v\\n&quot;, i)</span><br><span class=\"line\">\t\t\twaitGroup.Done()</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twaitGroup.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显然目的是想打印 1、2、3的，但是结果却都是3<br>这是因为 子协程中，打印用的都是同一个局部变量i，这个i 在循环结束之后会变成3，所以最终打印的结果就都是3 了（大部分时候）</p>\n<p>利用刚才学的race，这种使用协程的错误方式也可以通过 -race 参数 提前检测出来。<br>go test -v <strong>-race</strong> routine_test.go<br>检测结果：<br>……<br>WARNING: DATA RACE<br><strong>Read at 0x00c000116140 by goroutine 8:</strong><br>  command-line-arguments.TestRoutine.func1()<br>      D:/coding/golang/go_common_mistake/routine_test.go:16 +0x44</p>\n<p><strong>Previous write at 0x00c000116140 by goroutine 7:</strong><br>  command-line-arguments.TestRoutine()<br>      D:/coding/golang/go_common_mistake/routine_test.go:14 +0x104<br>  testing.tRunner()<br>      G:/Program Files/Go/src/testing/testing.go:1127 +0x202<br>……</p>\n<p>从错误信息可以看到，省略的部分还有其他协程，同样的警告信息。仔细分析下来就可以得到协程用的都是同一个局部变量的结论了。<br>怎么样，马上就体验到 -race 参数的作用了，是不是很妙</p>\n<h4 id=\"10-2-避免直接使用循环中的局部变量\"><a href=\"#10-2-避免直接使用循环中的局部变量\" class=\"headerlink\" title=\"10.2 避免直接使用循环中的局部变量\"></a>10.2 避免直接使用循环中的局部变量</h4><p>对于这种情况有两种解决方法：<br>1）go func 加上入参</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for _, i := range ints &#123;</span><br><span class=\"line\">\t\tgo func(i int) &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(&quot;%v\\n&quot;, i)</span><br><span class=\"line\">\t\t\twaitGroup.Done()</span><br><span class=\"line\">\t\t&#125;(i)</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2）循环内使用单独的局部变量<br><img src=\"/img/20210718105358253.png\" alt=\"在这里插入图片描述\"></p>\n<p>注意虽然这里的I 依然是局部变量，但是对每个开启的协程来说已经不是同一个了，每次进入循环的I 都是不一样的。<br>但是这里我更推荐第一种写法，逻辑更加清楚</p>\n"},{"title":"Hexo 博客搭建","cover":"/img/blog_img/hexo.png","_content":"\n# 如何通过 hexo 工具搭建自己的博客网站\n\n## 效果\n[博客首页](https://smiecj.github.io/)\n![blog front page]](hexo_blog_01.png)\n\n[博客标签页](https://smiecj.github.io/tags/)\n![blog tag page]](/hexo/hexo_blog_02.png)\n\n\n## 背景\n之前自己的博客都是放在csdn上，分类管理起来不是很方便，而且分类在左下角，不是特别显眼的地方\n![csdn page]](hexo_blog_03.png)\n\n公众号的标签功能还可以，不过自己还是希望有个个人站点能专门管理写过的博客，主题最好是能一目了然，不仅仅是别人看着方便，以后自己整理资料的时候找得也方便\n\n既然有这个需求，那就试试呗，看看个人站点怎么搭建，据说不难的\n\n## 踩坑记 - hugo工具短暂的体验\nhugo 是一个用golang 写的博客搭建工具，主要功能是可一键生成博客，我们自己只需要写markdown 格式的文章就行了，前端静态文件都是通过hugo 进行渲染生成的。方便是方便，但是一直没有找到特别满意的主题。\n其实自己对主题的要求也没有说特别高，主要是要简洁、重点明了就好了，那种特别花哨、或者是基本功能欠缺的主题都是不考虑的\n所以最后放弃了hugo。一次偶然的机会，和一个前端同学聊，知道了有hexo 这样一个工具，同样是生成博客的，那就试试呗\n\n[参考-hugo搭建教程](https://jeshs.github.io/2019/01/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%80%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/)\n\n>hugo基本指令:\n```\n创建一篇博客:\nhugo new site myblog\n启动服务:\nhugo server -D --bind=\"0.0.0.0\"\n```\n\n## hexo 主题介绍\nhexo 和 hugo 最大的优势我觉得就是主题库了，这里介绍几个个人感觉还不错的：\n\n主题 | 风格 | demo\n-----| ----- | -----\n[Indigo](https://github.com/yscoder/hexo-theme-indigo) | 蓝色主题、简洁 | [wuyang的个人博客](https://wuyang910217.github.io/)\n[butterfly](https://github.com/jerryc127/hexo-theme-butterfly) | 首页展示大幅背景图，表现力强 | [云玩家](https://yunist.cn/)\n[melody](https://github.com/Molunerfinn/hexo-theme-melody) | 白色主题、简洁 | [MARKSZのBlog](https://molunerfinn.com/)\n\n其实自己也是后面看了这些主题的样式，才发现原来好多大神的个人站点都是通过 hexo 搭建的，有些前端技术比较厉害的，还会尝试自己去魔改，希望自己也有一天可以尝试一下\n\n## 本地搭建方式\n### 环境准备\n[hexo](https://github.com/hexojs/hexo) 是 node 开发的框架，所以需要通过 npm 来安装\n\n>安装hexo 框架\n```\nnpm install -g hexo-cli\n```\n\n>创建博客工程\n```\nhexo init myblog\n```\n\n>结构简述：\n![hexo structure](hexo_blog_04.png)\n\n```\n_config.yml: 主配置文件，后续修改主题之类的就是改这里\nthemes: 主题目录\nscaffolds: 博客模板，通过 hexo new page 生成的页面都以这里的md 文件为模板\nsource: 存放用户资源\npackage.json: 本质上 hexo 博客还是一个前端项目，所以在这里管理依赖\n```\n\n### 设置主题\n这一步主要是在 **themes** 目录下，存放主题代码目录，这样 hexo 启动博客主页的时候，就是以你放的主题来生成了\n有两种下载主题的方式：你可以直接将主题git 代码下载下来，放到themes 目录，或者是fork 一份主题仓库，通过 git submodule clone 一份代码。如果有兴趣自己做主题魔改，更建议后者\n\n通过 git submodule 下载：\n```\ngit submodule add git@github.com:主题仓库.git themes/主题名称\n```\n\n下载完成之后，将_config.yml 中的主题名称修改一下\n![hexo structure](hexo_blog_05.png)\n\n安装渲染工具\n```\nnpm install hexo-renderer-pug hexo-renderer-stylus --save\nnpm install --save hexo-renderer-pug hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-renderer-stylus\n```\n\n### 启动博客\n\n>清理静态文件\n\n```\nhexo clean\n```\n\n>生成静态文件\n\n```\nhexo g\n```\n\n>启动服务\n\n```\nhexo server -w -p 3000\n\n# 启动服务\n# -w: watch，监听文件变化\n# -p: port，启动端口\n```\n\n到这一步完成，博客基本框架就算搭建成功了~\n\n## 基本配置的介绍\n这里我们对一些博客配置做简单的了解，方便后续进行主题设置。当然博客部署完成之后，也可以直接部署到github 上，先不管这些配置。你也可以直接跳到下一节内容进行参考。\n如果想了解大部分的配置，建议参考下面的官方教程\n[参考-官方教程](https://butterfly.js.org/posts/4aa8abbe/#Button)\n\n### 网站信息\n站点基本配置:\n![hexo structure](hexo_blog_06.png)\n\n头像和首页背景图:\n![hexo structure](hexo_blog_07.png)\n\n### 文章\n文章封面: 设置cover属性\n![hexo structure](hexo_blog_08.png)\n\n效果:\n![hexo structure](hexo_blog_09.png)\n\n\n### 顶部栏\n![hexo structure](hexo_blog_10.png)\n\n其中，标签、分类页面可通过下面的指令新建:\n```\nhexo new page tags\nhexo new page categories\n```\n\n## 部署到github站点\n\n### github 创建仓库\ngithub 能够识别 用户名.github.io 的仓库名，并部署这个仓库的静态文件生成站点，站点地址就是 用户名.github.io\n![hexo structure](hexo_blog_11.png)\n\n### 配置准备\n修改博客根目录的 config.yml 文件:\n```\ndeploy:\n  type: git\n  repo: <repository url> #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io\n  branch: master\n```\n\n这样先执行 **hexo g** 生成静态文件之后，再执行 **hexo d** 就可以将静态文件 提交到站点仓库上了\n如果是在本地开发，建议 repo 配置成 ssh 的地址，部署更方便\n\n## 总结\n天下无难事 -- 其实很早就看到过，这次尝试自己搭建，其实不麻烦\n当然，要真正做成一个内容丰富的个人博客站点，还是要慢慢积累丰富的内容才行。有的大神就纯做技术博客（比如[廖雪峰](https://www.liaoxuefeng.com/)），有的大神则搞一些炫酷的效果（如[云游君的小站](https://www.yunyoujun.cn/about/)），最后都能做得很有知名度。当然，最重要的还是要有核心的技术，博客积累关键还是在于个人的技术积累。\n所以，慢慢来吧，共勉","source":"_posts/hexo/hexo-deploy.md","raw":"---\ntitle: Hexo 博客搭建\ncover: /img/blog_img/hexo.png\ntags: ['博客搭建', 'hexo']\ncategories: ['博客搭建']\n---\n\n# 如何通过 hexo 工具搭建自己的博客网站\n\n## 效果\n[博客首页](https://smiecj.github.io/)\n![blog front page]](hexo_blog_01.png)\n\n[博客标签页](https://smiecj.github.io/tags/)\n![blog tag page]](/hexo/hexo_blog_02.png)\n\n\n## 背景\n之前自己的博客都是放在csdn上，分类管理起来不是很方便，而且分类在左下角，不是特别显眼的地方\n![csdn page]](hexo_blog_03.png)\n\n公众号的标签功能还可以，不过自己还是希望有个个人站点能专门管理写过的博客，主题最好是能一目了然，不仅仅是别人看着方便，以后自己整理资料的时候找得也方便\n\n既然有这个需求，那就试试呗，看看个人站点怎么搭建，据说不难的\n\n## 踩坑记 - hugo工具短暂的体验\nhugo 是一个用golang 写的博客搭建工具，主要功能是可一键生成博客，我们自己只需要写markdown 格式的文章就行了，前端静态文件都是通过hugo 进行渲染生成的。方便是方便，但是一直没有找到特别满意的主题。\n其实自己对主题的要求也没有说特别高，主要是要简洁、重点明了就好了，那种特别花哨、或者是基本功能欠缺的主题都是不考虑的\n所以最后放弃了hugo。一次偶然的机会，和一个前端同学聊，知道了有hexo 这样一个工具，同样是生成博客的，那就试试呗\n\n[参考-hugo搭建教程](https://jeshs.github.io/2019/01/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%80%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/)\n\n>hugo基本指令:\n```\n创建一篇博客:\nhugo new site myblog\n启动服务:\nhugo server -D --bind=\"0.0.0.0\"\n```\n\n## hexo 主题介绍\nhexo 和 hugo 最大的优势我觉得就是主题库了，这里介绍几个个人感觉还不错的：\n\n主题 | 风格 | demo\n-----| ----- | -----\n[Indigo](https://github.com/yscoder/hexo-theme-indigo) | 蓝色主题、简洁 | [wuyang的个人博客](https://wuyang910217.github.io/)\n[butterfly](https://github.com/jerryc127/hexo-theme-butterfly) | 首页展示大幅背景图，表现力强 | [云玩家](https://yunist.cn/)\n[melody](https://github.com/Molunerfinn/hexo-theme-melody) | 白色主题、简洁 | [MARKSZのBlog](https://molunerfinn.com/)\n\n其实自己也是后面看了这些主题的样式，才发现原来好多大神的个人站点都是通过 hexo 搭建的，有些前端技术比较厉害的，还会尝试自己去魔改，希望自己也有一天可以尝试一下\n\n## 本地搭建方式\n### 环境准备\n[hexo](https://github.com/hexojs/hexo) 是 node 开发的框架，所以需要通过 npm 来安装\n\n>安装hexo 框架\n```\nnpm install -g hexo-cli\n```\n\n>创建博客工程\n```\nhexo init myblog\n```\n\n>结构简述：\n![hexo structure](hexo_blog_04.png)\n\n```\n_config.yml: 主配置文件，后续修改主题之类的就是改这里\nthemes: 主题目录\nscaffolds: 博客模板，通过 hexo new page 生成的页面都以这里的md 文件为模板\nsource: 存放用户资源\npackage.json: 本质上 hexo 博客还是一个前端项目，所以在这里管理依赖\n```\n\n### 设置主题\n这一步主要是在 **themes** 目录下，存放主题代码目录，这样 hexo 启动博客主页的时候，就是以你放的主题来生成了\n有两种下载主题的方式：你可以直接将主题git 代码下载下来，放到themes 目录，或者是fork 一份主题仓库，通过 git submodule clone 一份代码。如果有兴趣自己做主题魔改，更建议后者\n\n通过 git submodule 下载：\n```\ngit submodule add git@github.com:主题仓库.git themes/主题名称\n```\n\n下载完成之后，将_config.yml 中的主题名称修改一下\n![hexo structure](hexo_blog_05.png)\n\n安装渲染工具\n```\nnpm install hexo-renderer-pug hexo-renderer-stylus --save\nnpm install --save hexo-renderer-pug hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-renderer-stylus\n```\n\n### 启动博客\n\n>清理静态文件\n\n```\nhexo clean\n```\n\n>生成静态文件\n\n```\nhexo g\n```\n\n>启动服务\n\n```\nhexo server -w -p 3000\n\n# 启动服务\n# -w: watch，监听文件变化\n# -p: port，启动端口\n```\n\n到这一步完成，博客基本框架就算搭建成功了~\n\n## 基本配置的介绍\n这里我们对一些博客配置做简单的了解，方便后续进行主题设置。当然博客部署完成之后，也可以直接部署到github 上，先不管这些配置。你也可以直接跳到下一节内容进行参考。\n如果想了解大部分的配置，建议参考下面的官方教程\n[参考-官方教程](https://butterfly.js.org/posts/4aa8abbe/#Button)\n\n### 网站信息\n站点基本配置:\n![hexo structure](hexo_blog_06.png)\n\n头像和首页背景图:\n![hexo structure](hexo_blog_07.png)\n\n### 文章\n文章封面: 设置cover属性\n![hexo structure](hexo_blog_08.png)\n\n效果:\n![hexo structure](hexo_blog_09.png)\n\n\n### 顶部栏\n![hexo structure](hexo_blog_10.png)\n\n其中，标签、分类页面可通过下面的指令新建:\n```\nhexo new page tags\nhexo new page categories\n```\n\n## 部署到github站点\n\n### github 创建仓库\ngithub 能够识别 用户名.github.io 的仓库名，并部署这个仓库的静态文件生成站点，站点地址就是 用户名.github.io\n![hexo structure](hexo_blog_11.png)\n\n### 配置准备\n修改博客根目录的 config.yml 文件:\n```\ndeploy:\n  type: git\n  repo: <repository url> #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io\n  branch: master\n```\n\n这样先执行 **hexo g** 生成静态文件之后，再执行 **hexo d** 就可以将静态文件 提交到站点仓库上了\n如果是在本地开发，建议 repo 配置成 ssh 的地址，部署更方便\n\n## 总结\n天下无难事 -- 其实很早就看到过，这次尝试自己搭建，其实不麻烦\n当然，要真正做成一个内容丰富的个人博客站点，还是要慢慢积累丰富的内容才行。有的大神就纯做技术博客（比如[廖雪峰](https://www.liaoxuefeng.com/)），有的大神则搞一些炫酷的效果（如[云游君的小站](https://www.yunyoujun.cn/about/)），最后都能做得很有知名度。当然，最重要的还是要有核心的技术，博客积累关键还是在于个人的技术积累。\n所以，慢慢来吧，共勉","slug":"hexo/hexo-deploy","published":1,"date":"2021-08-12T14:52:07.100Z","updated":"2021-08-12T16:18:51.230Z","_id":"cks7myt7j000jfzo4dr7gfmhc","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"如何通过-hexo-工具搭建自己的博客网站\"><a href=\"#如何通过-hexo-工具搭建自己的博客网站\" class=\"headerlink\" title=\"如何通过 hexo 工具搭建自己的博客网站\"></a>如何通过 hexo 工具搭建自己的博客网站</h1><h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p><a href=\"https://smiecj.github.io/\">博客首页</a><br>![blog front page]](hexo_blog_01.png)</p>\n<p><a href=\"https://smiecj.github.io/tags/\">博客标签页</a><br>![blog tag page]](/hexo/hexo_blog_02.png)</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>之前自己的博客都是放在csdn上，分类管理起来不是很方便，而且分类在左下角，不是特别显眼的地方<br>![csdn page]](hexo_blog_03.png)</p>\n<p>公众号的标签功能还可以，不过自己还是希望有个个人站点能专门管理写过的博客，主题最好是能一目了然，不仅仅是别人看着方便，以后自己整理资料的时候找得也方便</p>\n<p>既然有这个需求，那就试试呗，看看个人站点怎么搭建，据说不难的</p>\n<h2 id=\"踩坑记-hugo工具短暂的体验\"><a href=\"#踩坑记-hugo工具短暂的体验\" class=\"headerlink\" title=\"踩坑记 - hugo工具短暂的体验\"></a>踩坑记 - hugo工具短暂的体验</h2><p>hugo 是一个用golang 写的博客搭建工具，主要功能是可一键生成博客，我们自己只需要写markdown 格式的文章就行了，前端静态文件都是通过hugo 进行渲染生成的。方便是方便，但是一直没有找到特别满意的主题。<br>其实自己对主题的要求也没有说特别高，主要是要简洁、重点明了就好了，那种特别花哨、或者是基本功能欠缺的主题都是不考虑的<br>所以最后放弃了hugo。一次偶然的机会，和一个前端同学聊，知道了有hexo 这样一个工具，同样是生成博客的，那就试试呗</p>\n<p><a href=\"https://jeshs.github.io/2019/01/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%80%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/\">参考-hugo搭建教程</a></p>\n<blockquote>\n<p>hugo基本指令:</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建一篇博客:</span><br><span class=\"line\">hugo new site myblog</span><br><span class=\"line\">启动服务:</span><br><span class=\"line\">hugo server -D --bind=&quot;0.0.0.0&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"hexo-主题介绍\"><a href=\"#hexo-主题介绍\" class=\"headerlink\" title=\"hexo 主题介绍\"></a>hexo 主题介绍</h2><p>hexo 和 hugo 最大的优势我觉得就是主题库了，这里介绍几个个人感觉还不错的：</p>\n<table>\n<thead>\n<tr>\n<th>主题</th>\n<th>风格</th>\n<th>demo</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://github.com/yscoder/hexo-theme-indigo\">Indigo</a></td>\n<td>蓝色主题、简洁</td>\n<td><a href=\"https://wuyang910217.github.io/\">wuyang的个人博客</a></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/jerryc127/hexo-theme-butterfly\">butterfly</a></td>\n<td>首页展示大幅背景图，表现力强</td>\n<td><a href=\"https://yunist.cn/\">云玩家</a></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/Molunerfinn/hexo-theme-melody\">melody</a></td>\n<td>白色主题、简洁</td>\n<td><a href=\"https://molunerfinn.com/\">MARKSZのBlog</a></td>\n</tr>\n</tbody></table>\n<p>其实自己也是后面看了这些主题的样式，才发现原来好多大神的个人站点都是通过 hexo 搭建的，有些前端技术比较厉害的，还会尝试自己去魔改，希望自己也有一天可以尝试一下</p>\n<h2 id=\"本地搭建方式\"><a href=\"#本地搭建方式\" class=\"headerlink\" title=\"本地搭建方式\"></a>本地搭建方式</h2><h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p><a href=\"https://github.com/hexojs/hexo\">hexo</a> 是 node 开发的框架，所以需要通过 npm 来安装</p>\n<blockquote>\n<p>安装hexo 框架</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>创建博客工程</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init myblog</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>结构简述：<br><img src=\"hexo_blog_04.png\" alt=\"hexo structure\"></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_config.yml: 主配置文件，后续修改主题之类的就是改这里</span><br><span class=\"line\">themes: 主题目录</span><br><span class=\"line\">scaffolds: 博客模板，通过 hexo new page 生成的页面都以这里的md 文件为模板</span><br><span class=\"line\">source: 存放用户资源</span><br><span class=\"line\">package.json: 本质上 hexo 博客还是一个前端项目，所以在这里管理依赖</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设置主题\"><a href=\"#设置主题\" class=\"headerlink\" title=\"设置主题\"></a>设置主题</h3><p>这一步主要是在 <strong>themes</strong> 目录下，存放主题代码目录，这样 hexo 启动博客主页的时候，就是以你放的主题来生成了<br>有两种下载主题的方式：你可以直接将主题git 代码下载下来，放到themes 目录，或者是fork 一份主题仓库，通过 git submodule clone 一份代码。如果有兴趣自己做主题魔改，更建议后者</p>\n<p>通过 git submodule 下载：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule add git@github.com:主题仓库.git themes/主题名称</span><br></pre></td></tr></table></figure>\n\n<p>下载完成之后，将_config.yml 中的主题名称修改一下<br><img src=\"hexo_blog_05.png\" alt=\"hexo structure\"></p>\n<p>安装渲染工具</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class=\"line\">npm install --save hexo-renderer-pug hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-renderer-stylus</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动博客\"><a href=\"#启动博客\" class=\"headerlink\" title=\"启动博客\"></a>启动博客</h3><blockquote>\n<p>清理静态文件</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>生成静态文件</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>启动服务</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server -w -p 3000</span><br><span class=\"line\"></span><br><span class=\"line\"># 启动服务</span><br><span class=\"line\"># -w: watch，监听文件变化</span><br><span class=\"line\"># -p: port，启动端口</span><br></pre></td></tr></table></figure>\n\n<p>到这一步完成，博客基本框架就算搭建成功了~</p>\n<h2 id=\"基本配置的介绍\"><a href=\"#基本配置的介绍\" class=\"headerlink\" title=\"基本配置的介绍\"></a>基本配置的介绍</h2><p>这里我们对一些博客配置做简单的了解，方便后续进行主题设置。当然博客部署完成之后，也可以直接部署到github 上，先不管这些配置。你也可以直接跳到下一节内容进行参考。<br>如果想了解大部分的配置，建议参考下面的官方教程<br><a href=\"https://butterfly.js.org/posts/4aa8abbe/#Button\">参考-官方教程</a></p>\n<h3 id=\"网站信息\"><a href=\"#网站信息\" class=\"headerlink\" title=\"网站信息\"></a>网站信息</h3><p>站点基本配置:<br><img src=\"hexo_blog_06.png\" alt=\"hexo structure\"></p>\n<p>头像和首页背景图:<br><img src=\"hexo_blog_07.png\" alt=\"hexo structure\"></p>\n<h3 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h3><p>文章封面: 设置cover属性<br><img src=\"hexo_blog_08.png\" alt=\"hexo structure\"></p>\n<p>效果:<br><img src=\"hexo_blog_09.png\" alt=\"hexo structure\"></p>\n<h3 id=\"顶部栏\"><a href=\"#顶部栏\" class=\"headerlink\" title=\"顶部栏\"></a>顶部栏</h3><p><img src=\"hexo_blog_10.png\" alt=\"hexo structure\"></p>\n<p>其中，标签、分类页面可通过下面的指令新建:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page tags</span><br><span class=\"line\">hexo new page categories</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"部署到github站点\"><a href=\"#部署到github站点\" class=\"headerlink\" title=\"部署到github站点\"></a>部署到github站点</h2><h3 id=\"github-创建仓库\"><a href=\"#github-创建仓库\" class=\"headerlink\" title=\"github 创建仓库\"></a>github 创建仓库</h3><p>github 能够识别 用户名.github.io 的仓库名，并部署这个仓库的静态文件生成站点，站点地址就是 用户名.github.io<br><img src=\"hexo_blog_11.png\" alt=\"hexo structure\"></p>\n<h3 id=\"配置准备\"><a href=\"#配置准备\" class=\"headerlink\" title=\"配置准备\"></a>配置准备</h3><p>修改博客根目录的 config.yml 文件:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<p>这样先执行 <strong>hexo g</strong> 生成静态文件之后，再执行 <strong>hexo d</strong> 就可以将静态文件 提交到站点仓库上了<br>如果是在本地开发，建议 repo 配置成 ssh 的地址，部署更方便</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>天下无难事 – 其实很早就看到过，这次尝试自己搭建，其实不麻烦<br>当然，要真正做成一个内容丰富的个人博客站点，还是要慢慢积累丰富的内容才行。有的大神就纯做技术博客（比如<a href=\"https://www.liaoxuefeng.com/\">廖雪峰</a>），有的大神则搞一些炫酷的效果（如<a href=\"https://www.yunyoujun.cn/about/\">云游君的小站</a>），最后都能做得很有知名度。当然，最重要的还是要有核心的技术，博客积累关键还是在于个人的技术积累。<br>所以，慢慢来吧，共勉</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"如何通过-hexo-工具搭建自己的博客网站\"><a href=\"#如何通过-hexo-工具搭建自己的博客网站\" class=\"headerlink\" title=\"如何通过 hexo 工具搭建自己的博客网站\"></a>如何通过 hexo 工具搭建自己的博客网站</h1><h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p><a href=\"https://smiecj.github.io/\">博客首页</a><br>![blog front page]](hexo_blog_01.png)</p>\n<p><a href=\"https://smiecj.github.io/tags/\">博客标签页</a><br>![blog tag page]](/hexo/hexo_blog_02.png)</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>之前自己的博客都是放在csdn上，分类管理起来不是很方便，而且分类在左下角，不是特别显眼的地方<br>![csdn page]](hexo_blog_03.png)</p>\n<p>公众号的标签功能还可以，不过自己还是希望有个个人站点能专门管理写过的博客，主题最好是能一目了然，不仅仅是别人看着方便，以后自己整理资料的时候找得也方便</p>\n<p>既然有这个需求，那就试试呗，看看个人站点怎么搭建，据说不难的</p>\n<h2 id=\"踩坑记-hugo工具短暂的体验\"><a href=\"#踩坑记-hugo工具短暂的体验\" class=\"headerlink\" title=\"踩坑记 - hugo工具短暂的体验\"></a>踩坑记 - hugo工具短暂的体验</h2><p>hugo 是一个用golang 写的博客搭建工具，主要功能是可一键生成博客，我们自己只需要写markdown 格式的文章就行了，前端静态文件都是通过hugo 进行渲染生成的。方便是方便，但是一直没有找到特别满意的主题。<br>其实自己对主题的要求也没有说特别高，主要是要简洁、重点明了就好了，那种特别花哨、或者是基本功能欠缺的主题都是不考虑的<br>所以最后放弃了hugo。一次偶然的机会，和一个前端同学聊，知道了有hexo 这样一个工具，同样是生成博客的，那就试试呗</p>\n<p><a href=\"https://jeshs.github.io/2019/01/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%80%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/\">参考-hugo搭建教程</a></p>\n<blockquote>\n<p>hugo基本指令:</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建一篇博客:</span><br><span class=\"line\">hugo new site myblog</span><br><span class=\"line\">启动服务:</span><br><span class=\"line\">hugo server -D --bind=&quot;0.0.0.0&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"hexo-主题介绍\"><a href=\"#hexo-主题介绍\" class=\"headerlink\" title=\"hexo 主题介绍\"></a>hexo 主题介绍</h2><p>hexo 和 hugo 最大的优势我觉得就是主题库了，这里介绍几个个人感觉还不错的：</p>\n<table>\n<thead>\n<tr>\n<th>主题</th>\n<th>风格</th>\n<th>demo</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://github.com/yscoder/hexo-theme-indigo\">Indigo</a></td>\n<td>蓝色主题、简洁</td>\n<td><a href=\"https://wuyang910217.github.io/\">wuyang的个人博客</a></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/jerryc127/hexo-theme-butterfly\">butterfly</a></td>\n<td>首页展示大幅背景图，表现力强</td>\n<td><a href=\"https://yunist.cn/\">云玩家</a></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/Molunerfinn/hexo-theme-melody\">melody</a></td>\n<td>白色主题、简洁</td>\n<td><a href=\"https://molunerfinn.com/\">MARKSZのBlog</a></td>\n</tr>\n</tbody></table>\n<p>其实自己也是后面看了这些主题的样式，才发现原来好多大神的个人站点都是通过 hexo 搭建的，有些前端技术比较厉害的，还会尝试自己去魔改，希望自己也有一天可以尝试一下</p>\n<h2 id=\"本地搭建方式\"><a href=\"#本地搭建方式\" class=\"headerlink\" title=\"本地搭建方式\"></a>本地搭建方式</h2><h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p><a href=\"https://github.com/hexojs/hexo\">hexo</a> 是 node 开发的框架，所以需要通过 npm 来安装</p>\n<blockquote>\n<p>安装hexo 框架</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>创建博客工程</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init myblog</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>结构简述：<br><img src=\"hexo_blog_04.png\" alt=\"hexo structure\"></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_config.yml: 主配置文件，后续修改主题之类的就是改这里</span><br><span class=\"line\">themes: 主题目录</span><br><span class=\"line\">scaffolds: 博客模板，通过 hexo new page 生成的页面都以这里的md 文件为模板</span><br><span class=\"line\">source: 存放用户资源</span><br><span class=\"line\">package.json: 本质上 hexo 博客还是一个前端项目，所以在这里管理依赖</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设置主题\"><a href=\"#设置主题\" class=\"headerlink\" title=\"设置主题\"></a>设置主题</h3><p>这一步主要是在 <strong>themes</strong> 目录下，存放主题代码目录，这样 hexo 启动博客主页的时候，就是以你放的主题来生成了<br>有两种下载主题的方式：你可以直接将主题git 代码下载下来，放到themes 目录，或者是fork 一份主题仓库，通过 git submodule clone 一份代码。如果有兴趣自己做主题魔改，更建议后者</p>\n<p>通过 git submodule 下载：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule add git@github.com:主题仓库.git themes/主题名称</span><br></pre></td></tr></table></figure>\n\n<p>下载完成之后，将_config.yml 中的主题名称修改一下<br><img src=\"hexo_blog_05.png\" alt=\"hexo structure\"></p>\n<p>安装渲染工具</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class=\"line\">npm install --save hexo-renderer-pug hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-renderer-stylus</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动博客\"><a href=\"#启动博客\" class=\"headerlink\" title=\"启动博客\"></a>启动博客</h3><blockquote>\n<p>清理静态文件</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>生成静态文件</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>启动服务</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server -w -p 3000</span><br><span class=\"line\"></span><br><span class=\"line\"># 启动服务</span><br><span class=\"line\"># -w: watch，监听文件变化</span><br><span class=\"line\"># -p: port，启动端口</span><br></pre></td></tr></table></figure>\n\n<p>到这一步完成，博客基本框架就算搭建成功了~</p>\n<h2 id=\"基本配置的介绍\"><a href=\"#基本配置的介绍\" class=\"headerlink\" title=\"基本配置的介绍\"></a>基本配置的介绍</h2><p>这里我们对一些博客配置做简单的了解，方便后续进行主题设置。当然博客部署完成之后，也可以直接部署到github 上，先不管这些配置。你也可以直接跳到下一节内容进行参考。<br>如果想了解大部分的配置，建议参考下面的官方教程<br><a href=\"https://butterfly.js.org/posts/4aa8abbe/#Button\">参考-官方教程</a></p>\n<h3 id=\"网站信息\"><a href=\"#网站信息\" class=\"headerlink\" title=\"网站信息\"></a>网站信息</h3><p>站点基本配置:<br><img src=\"hexo_blog_06.png\" alt=\"hexo structure\"></p>\n<p>头像和首页背景图:<br><img src=\"hexo_blog_07.png\" alt=\"hexo structure\"></p>\n<h3 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h3><p>文章封面: 设置cover属性<br><img src=\"hexo_blog_08.png\" alt=\"hexo structure\"></p>\n<p>效果:<br><img src=\"hexo_blog_09.png\" alt=\"hexo structure\"></p>\n<h3 id=\"顶部栏\"><a href=\"#顶部栏\" class=\"headerlink\" title=\"顶部栏\"></a>顶部栏</h3><p><img src=\"hexo_blog_10.png\" alt=\"hexo structure\"></p>\n<p>其中，标签、分类页面可通过下面的指令新建:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page tags</span><br><span class=\"line\">hexo new page categories</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"部署到github站点\"><a href=\"#部署到github站点\" class=\"headerlink\" title=\"部署到github站点\"></a>部署到github站点</h2><h3 id=\"github-创建仓库\"><a href=\"#github-创建仓库\" class=\"headerlink\" title=\"github 创建仓库\"></a>github 创建仓库</h3><p>github 能够识别 用户名.github.io 的仓库名，并部署这个仓库的静态文件生成站点，站点地址就是 用户名.github.io<br><img src=\"hexo_blog_11.png\" alt=\"hexo structure\"></p>\n<h3 id=\"配置准备\"><a href=\"#配置准备\" class=\"headerlink\" title=\"配置准备\"></a>配置准备</h3><p>修改博客根目录的 config.yml 文件:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<p>这样先执行 <strong>hexo g</strong> 生成静态文件之后，再执行 <strong>hexo d</strong> 就可以将静态文件 提交到站点仓库上了<br>如果是在本地开发，建议 repo 配置成 ssh 的地址，部署更方便</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>天下无难事 – 其实很早就看到过，这次尝试自己搭建，其实不麻烦<br>当然，要真正做成一个内容丰富的个人博客站点，还是要慢慢积累丰富的内容才行。有的大神就纯做技术博客（比如<a href=\"https://www.liaoxuefeng.com/\">廖雪峰</a>），有的大神则搞一些炫酷的效果（如<a href=\"https://www.yunyoujun.cn/about/\">云游君的小站</a>），最后都能做得很有知名度。当然，最重要的还是要有核心的技术，博客积累关键还是在于个人的技术积累。<br>所以，慢慢来吧，共勉</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cks7mylyf000gfzo471bb3gym","category_id":"cks77b4uo00046bqsdipddemf","_id":"cks7mylyi000ifzo426ci42de"},{"post_id":"cks7myt7j000jfzo4dr7gfmhc","category_id":"cks7mrl460008fzo4157a846y","_id":"cks7myt7k000mfzo404ai5qla"}],"PostTag":[{"post_id":"cks7mylyf000gfzo471bb3gym","tag_id":"cks77b4up00056bqsd2kkah7c","_id":"cks7mylyh000hfzo4htylewn2"},{"post_id":"cks7myt7j000jfzo4dr7gfmhc","tag_id":"cks7mrl460009fzo4def18cwm","_id":"cks7myt7k000kfzo47nsc47y0"},{"post_id":"cks7myt7j000jfzo4dr7gfmhc","tag_id":"cks7mrm3a000efzo43kpv8gkl","_id":"cks7myt7k000lfzo48e9pglcm"}],"Tag":[{"name":"golang","_id":"cks77b4up00056bqsd2kkah7c"},{"name":"博客","_id":"cks7mr72r0006fzo4bfctg1om"},{"name":"博客搭建","_id":"cks7mrl460009fzo4def18cwm"},{"name":"hexp","_id":"cks7mrl48000afzo4bi76bxxr"},{"name":"hexo","_id":"cks7mrm3a000efzo43kpv8gkl"}]}}